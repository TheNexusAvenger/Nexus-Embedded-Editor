<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Script" referent="1">
      <Properties>
        <string name="Name">NexusEmbeddedVSCode</string>
        <string name="Source">--[[
TheNexusAvenger

Initializes Nexus Embedded VS Code.
--]]

require(script:WaitForChild("NexusEmbeddedEditor"))(plugin,35871,"VS Code","http://www.roblox.com/asset/?id=4790867149","http://www.roblox.com/asset/?id=4790887903")</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">NexusEmbeddedEditor</string>
          <string name="Source">--[[
TheNexusAvenger

Common script for initializing the plugin.
--]]

local NexusPluginFramework = require(script.Parent:WaitForChild("NexusPluginFramework"))
local EmbeddedEditorSession = require(script:WaitForChild("EmbeddedEditorSession"))
local ConnectToggleButton = require(script:WaitForChild("ConnectToggleButton"))
local AttachToggleButton = require(script:WaitForChild("AttachToggleButton"))



return function(Plugin,Port,EditorName,EditorConnectIcon,EditorAttachIcon)
    --Initialize the plugin framework.
    NexusPluginFramework:SetPlugin(Plugin)

    --Initialize the session.
    local Session = EmbeddedEditorSession.new(Port)
    Session:StartContinousUpdates()

    --Create the toolbar and buttons.
    local NexusEmbeddedEditorToolbar = NexusPluginFramework.new("PluginToolbar","Embedded "..EditorName)
    ConnectToggleButton.new(EditorName,NexusEmbeddedEditorToolbar,Session,EditorConnectIcon)
    AttachToggleButton.new(EditorName,NexusEmbeddedEditorToolbar,Session,EditorAttachIcon)

    --Create the plugin actions.
    local DB = true
    Plugin:CreatePluginAction("NexusEmbedded"..EditorName.."_Connect","Connect "..EditorName,"Connects the external editor "..EditorName.." to Roblox Studio.\nPart of Nexus Embedded "..EditorName..".",EditorConnectIcon).Triggered:Connect(function()
        if DB then
            DB = false
            Session:ConnectEditor()

            wait()
            DB = true
        end
    end)
    Plugin:CreatePluginAction("NexusEmbedded"..EditorName.."_Disconnect","Disonnect "..EditorName,"Disconnects the external editor "..EditorName.." to Roblox Studio.\nPart of Nexus Embedded "..EditorName..".",EditorConnectIcon).Triggered:Connect(function()
        if DB then
            DB = false
            Session:DisconnectEditor()

            wait()
            DB = true
        end
    end)
    Plugin:CreatePluginAction("NexusEmbedded"..EditorName.."_Attach","Attach "..EditorName,"Attaches the external editor "..EditorName.." to Roblox Studio.\nPart of Nexus Embedded "..EditorName..".",EditorAttachIcon).Triggered:Connect(function()
        if DB then
            DB = false
            Session:AttachEditor()

            wait()
            DB = true
        end
    end)
    Plugin:CreatePluginAction("NexusEmbedded"..EditorName.."_Detach","Attach "..EditorName,"Detaches the external editor "..EditorName.." to Roblox Studio.\nPart of Nexus Embedded "..EditorName..".",EditorAttachIcon).Triggered:Connect(function()
        if DB then
            DB = false
            Session:DetachEditor()

            wait()
            DB = true
        end
    end)
end</string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">AttachToggleButton</string>
            <string name="Source">--[[
TheNexusAvenger

Toggle button for attaching an external editor.
--]]

local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFramework"))

local AttachToggleButton = NexusPluginFramework:GetResource("Plugin.NexusPluginButton"):Extend()
AttachToggleButton:SetClassName("AttachToggleButton")



--[[
Creates the toggle button.
--]]
function AttachToggleButton:__new(EditorName,Toolbar,Session,Icon)
    self:InitializeSuper(Toolbar,"Attach "..EditorName,"Attaches "..EditorName.." to the Roblox Studio editor. Connects the editor if not done so already.",Icon)
    self.ClickableWhenViewportHidden = true
    
    --Set up connecting the button being active.
    Session:GetPropertyChangedSignal("Attached"):Connect(function()
        self.Active = Session.Attached
    end)

    --Set up the button being clicked.
    local DB = true
    self.Click:Connect(function()
        self:SetActive(Session.Attached)

		if DB then
			DB = false
            if Session.Attached then
                Session:DetachEditor()
            else
                Session:ConnectEditor()
                Session:AttachEditor()
                Session:UpdateOpenScript()
            end
			
			wait()
			DB = true
		end
	end)
end



return AttachToggleButton</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">ConnectToggleButton</string>
            <string name="Source">--[[
TheNexusAvenger

Toggle button for connecting an external editor.
--]]

local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFramework"))

local ConnectToggleButton = NexusPluginFramework:GetResource("Plugin.NexusPluginButton"):Extend()
ConnectToggleButton:SetClassName("ConnectToggleButton")



--[[
Creates the toggle button.
--]]
function ConnectToggleButton:__new(EditorName,Toolbar,Session,Icon)
    self:InitializeSuper(Toolbar,"Connect "..EditorName,"Connects "..EditorName.." without attaching it to the Roblox Studio editor.",Icon)
    self.ClickableWhenViewportHidden = true
    
    --Set up connecting the button being active.
    Session:GetPropertyChangedSignal("Connected"):Connect(function()
        self.Active = Session.Connected
    end)

    --Set up the button being clicked.
    local DB = true
	self.Click:Connect(function()
        self:SetActive(Session.Attached)
        
		if DB then
			DB = false
            if Session.Connected then
                Session:DisconnectEditor()
            else
                Session:ConnectEditor()
                Session:UpdateOpenScript()
            end
			
			wait()
			DB = true
		end
	end)
end



return ConnectToggleButton</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">EmbeddedEditorSession</string>
            <string name="Source">--[[
TheNexusAvenger

Session for Nexus Embedded Editor.
--]]

local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFramework"))
local NexusInstance = NexusPluginFramework:GetResource("NexusInstance.NexusInstance")

local EmbeddedEditorSession = NexusInstance:Extend()
EmbeddedEditorSession:SetClassName("EmbeddedEditorSession")

local HttpService = game:GetService("HttpService")
local StudioService = game:GetService("StudioService")



--[[
Performs an HTTP request and returns the response.
Throws an error if an HTTP or transport error occured.
--]]
local function RequestAsync(Request)
	--Send the requesst.
	local Response = HttpService:RequestAsync(Request)
	
	--Raise an error if an HTTP Error was returned.
	local Body = Response.Body
	if Response.StatusCode >= 400 then
		error(Body)
	end
	
	--Return the content.
	return Body
end


--[[
Sends a HTTP GET request and returns the response.
Throws an error if an HTTP or transport error occured.
--]]
local function GetAsync(Url)
	return RequestAsync({
		Url = Url,
		Method = "GET",
	})
end

--[[
Sends a HTTP POST request and returns the response.
Throws an error if an HTTP or transport error occured.
--]]
local function PostAsync(Url,Content)
	return RequestAsync({
		Url = Url,
		Method = "POST",
		Body = Content,
		Headers = {
            ["Content-Type"] = "text/plain",
		},
	})
end



--[[
Creates an Embedded Editor Session object.
--]]
function EmbeddedEditorSession:__new(Port)
    self:InitializeSuper()
    
    self.SessionId = HttpService:GenerateGUID()
    self.Connected = false
    self.Attached = false
    self.DB = true
    self.Port = Port
    self.TemporaryScriptsMap = {}
end

--[[
Updates the state based on the current status.
Returns if there was an error for calls where this is called first.
--]]
function EmbeddedEditorSession:UpdateState(SurpressWarnings)
    --Send the session request.
    local Worked,Return = pcall(function()
        return GetAsync("http://localhost:"..tostring(self.Port).."/session?session="..self.SessionId)
    end)

    --Update the state if the request was successful and got a response.
    if Worked then
        self.Connected = true
        self.Attached = HttpService:JSONDecode(Return).attached
        return false
    end

    --Output a warning message and return if the error was connection related.
    self.Connected = false
    self.Attached = false
    if Return == "Http requests are not enabled. Enable via game settings" then
        if not SurpressWarnings then
            warn("The HttpService is disabled. Nexus Embedded Editor requires it to be enabled to communicate with the editor server.")
        end
        return true
    elseif Return == "HttpError: ConnectFail" then
        if not SurpressWarnings then
            warn("Nexus Embedded Editor server is unreachable. Is it active?")
            warn("Make sure the server is running in the operating system.")
            warn("More information and the server files: Github/TheNexusAvenger/Nexus-Embedded-Editor")
        end
        return true
    elseif string.find(Return,"Session not found") then
        return false
    else
        if not SurpressWarnings then
            warn("Error occured getting status: "..tostring(Return))
        end
        return true
    end
end

--[[
Connects the editor.
--]]
function EmbeddedEditorSession:ConnectEditor()
    if not self.DB then return end
    self.DB = false

    --Update the current state in case something changed.
    if self:UpdateState() then self.DB = true return end

    if not self.Connected then
        --Create the script to connect.
        local ConnectScript = Instance.new("Script")
        ConnectScript.Name = self.SessionId
        ConnectScript.Source = "--[[\nNexus Embedded Editor is attempting detection.\nDo not close or unfocus this script.\n\nSession: "..self.SessionId.."\n--]]"
        ConnectScript.Archivable = false
        ConnectScript.Parent = game:GetService("ServerScriptService")
        NexusPluginFramework:GetPlugin():OpenScript(ConnectScript)

        --Send the connect request.
        local Worked,Return = pcall(function()
            return PostAsync("http://localhost:"..tostring(self.Port).."/connect?session="..self.SessionId,"Unused")
        end)

        --Warn that the detection failed.
        if not Worked then
            warn("Nexus Embedded Editor server failed to detect. Did you unfocus the script?")
            warn("\tError: "..tostring(Return))
        end

        --Destroy the connect script.
        ConnectScript:Destroy()
    end

    --Update the state.
    self:UpdateState()
    self.DB = true
end

--[[
Disconnects the editor.
--]]
function EmbeddedEditorSession:DisconnectEditor()
    if not self.DB then return end
    self.DB = false

    --Update the current state in case something changed.
    if self:UpdateState() then self.DB = true return end

    if self.Connected then
        --Send the disconnect request.
        local Worked,Return = pcall(function()
            return PostAsync("http://localhost:"..tostring(self.Port).."/disconnect?session="..self.SessionId,"Unused")
        end)

        --Warn that the disconnect failed.
        if not Worked then
            warn("Nexus Embedded Editor server failed to disconnect because "..tostring(Return))
        end

        --Clear the temporary scripts to fetch.
        self.TemporaryScriptsMap = {}
    end

    --Update the state.
    self:UpdateState()
    self.DB = true
end

--[[
Attaches the editor.
--]]
function EmbeddedEditorSession:AttachEditor()
    if not self.DB then return end
    self.DB = false

    --Update the current state in case something changed.
    if self:UpdateState() then self.DB = true return end

    if not self.Attached then
        --Send the attach request.
        local Worked,Return = pcall(function()
            return PostAsync("http://localhost:"..tostring(self.Port).."/attach?session="..self.SessionId,"Unused")
        end)

        --Warn that the attach failed.
        if not Worked then
            warn("Nexus Embedded Editor server failed to attach because "..tostring(Return))
        end
    end

    --Update the state.
    self:UpdateState()
    self.DB = true
end

--[[
Detaches the editor.
--]]
function EmbeddedEditorSession:DetachEditor()
    if not self.DB then return end
    self.DB = false

    --Update the current state in case something changed.
    if self:UpdateState() then self.DB = true return end

    if self.Attached then
        --Send the detach request.
        local Worked,Return = pcall(function()
            return PostAsync("http://localhost:"..tostring(self.Port).."/detach?session="..self.SessionId,"Unused")
        end)

        --Warn that the detach failed.
        if not Worked then
            warn("Nexus Embedded Editor server failed to detach because "..tostring(Return))
        end
    end

    --Update the state.
    self:UpdateState()
    self.DB = true
end

--[[
Updates the script that is open in Roblox studio.
--]]
function EmbeddedEditorSession:UpdateOpenScript()
    if self.Connected then
        local OpenScript = StudioService.ActiveScript
        if OpenScript then
            --Send the open script request.
            local Worked,Return = pcall(function()
                return PostAsync("http://localhost:"..tostring(self.Port).."/openscript?session="..self.SessionId.."&amp;script="..OpenScript:GetFullName(),OpenScript.Source)
            end)

            --Add the temporary script.
            if Worked and Return == "true" then
                self.TemporaryScriptsMap[OpenScript] = OpenScript:GetFullName()
            end

            --Warn that the open script failed.
            if not Worked then
                warn("Nexus Embedded Editor server failed to open script because "..tostring(Return))
            end
        end
    end
end

--[[
Updates the source of the temporary scripts.
--]]
function EmbeddedEditorSession:UpdateTemporaryScripts()
    if self.Connected then
        --Update the scripts.
        local ScriptsToRemove = {}
        for Script,Path in pairs(self.TemporaryScriptsMap) do
            local Worked,Return = pcall(function()
                Script.Source = GetAsync("http://localhost:"..tostring(self.Port).."/readscript?session="..self.SessionId.."&amp;script="..Path)
            end)
            if not Worked then
                ScriptsToRemove[Script] = true
            end
        end

        --Remove the scripts that return server errors.
        for Script,_ in pairs(ScriptsToRemove) do
            self.TemporaryScriptsMap[Script] = nil
        end
    end
end

--[[
Starts updating the state continously in the background.
--]]
function EmbeddedEditorSession:StartContinousUpdates()
    --Set up state updating.
    spawn(function()
        while true do
            self:UpdateState(true)
            wait(1)
        end
    end)

    --Set up updating the scripts.
    spawn(function()
        while true do
            self:UpdateTemporaryScripts()
            wait(1)
        end
    end)

    --Set up script updating.
    StudioService:GetPropertyChangedSignal("ActiveScript"):Connect(function()
        self:UpdateOpenScript()
    end)
end



return EmbeddedEditorSession</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">NexusPluginFramework</string>
          <string name="Source">--[[
TheNexusAvenger

Main module for Nexus Plugin Framework.
Version 0.1.0
--]]

local NEXUS_CLASS_PATHS = {
	--Signal Classes
	["Signal"] = "NexusInstance.Event.RobloxEvent",
	
	--Plugin
	["PluginButton"] = "Plugin.NexusPluginButton",
	["PluginGui"] = "Plugin.NexusPluginGui",
	["PluginToolbar"] = "Plugin.NexusPluginToolbar",
	["UserInput"] = "Plugin.NexusUserInput",
	
	--UI Classes
	["CollapsableListFrame"] = "UI.CollapsableList.NexusCollapsableListFrame",
	["ListContentsPropertyConstraint"] = "UI.CollapsableList.Constraint.NexusContentsPropertyConstraint",
	["ListMultiConstraint"] = "UI.CollapsableList.Constraint.NexusMultiConstraint",
	["ListSelectionConstraint"] = "UI.CollapsableList.Constraint.NexusSelectionConstraint",
	["BoundingSizeConstraint"] = "UI.Constraint.NexusBoundingSizeConstraint",
	["CheckBox"] = "UI.Input.NexusCheckBox",
	["ImageButton"] = "UI.Input.NexusImageButton",
	["TextBox"] = "UI.Input.NexusTextBox",
	["ScrollBar"] = "UI.Scroll.NexusScrollBar",
	["ScrollingFrame"] = "UI.Scroll.NexusScrollingFrame",
}



local NexusPluginFramework = require(script:WaitForChild("NexusPluginFrameworkProject"))
local NexusPlugin = NexusPluginFramework:GetResource("Plugin.NexusPlugin")
local NexusSettings = NexusPluginFramework:GetResource("Plugin.NexusSettings")
NexusPluginFramework.NexusEnum = NexusPluginFramework:GetResource("Data.Enum.NexusEnumCollection").GetBuiltInEnums()



--[[
Creates either a Nexus Plugin Framework class or a wrapped Roblox
class for Nexus Plugin Framework. Not all classes are exposed 
through this function.
--]]
function NexusPluginFramework.new(ClassName,...)
	--Return a Nexus Plugin Framework class if any.
	local Path = NEXUS_CLASS_PATHS[ClassName]
	if Path then
		return NexusPluginFramework:GetClass(ClassName).new(...)
	end
	
	--Return a wrapped class.
	local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
	return NexusWrappedInstance.GetInstance(ClassName)
end

--[[
Returns the class for a given name.
--]]
function NexusPluginFramework:GetClass(ClassName)
	local Path = NEXUS_CLASS_PATHS[ClassName]
	if not Path then
		error("Class does not exist: "..ClassName)
	end
	return NexusPluginFramework:GetResource(Path)
end

--[[
Sets the plugin instance. Needed when
initializing the framework.
--]]
function NexusPluginFramework:SetPlugin(Plugin)
	return NexusPlugin.SetPlugin(Plugin)
end

--[[
Returns the plugin instance.
--]]
function NexusPluginFramework:GetPlugin()
	return NexusPlugin.GetPlugin()
end

--[[
Returns the settings instance.
--]]
function NexusPluginFramework:GetSettings()
	return NexusSettings.GetSettings()
end



return NexusPluginFramework</string>
        </Properties>
        <Item class="Folder" referent="7">
          <Properties>
            <string name="Name">Base</string>
          </Properties>
          <Item class="ModuleScript" referent="8">
            <Properties>
              <string name="Name">NexusContainer</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox Instances for containing children and being parented.
--]]

local CLASS_NAME = "NexusContainer"

local INFINITE_YEILD_DELAY = 5



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local OverridableIndexInstance = NexusPluginFramework:GetResource("Base.OverridableIndexInstance")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")
local NexusConnection = NexusPluginFramework:GetResource("NexusInstance.Event.NexusConnection")

local NexusContainer = OverridableIndexInstance:Extend()
NexusContainer:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusContainer)



--[[
Creates a Nexus Container object.
--]]
function NexusContainer:__new()
	self:InitializeSuper()
	
	self.__Children = {}
	self.__DescendantEvents = {}
	self.__EventsToClear = {}
	self.__ConnectionsToClear = {}
	self.Name = self.ClassName
	self.Archivable = true
	self.Hidden = false
	
	--Create the events.
	self.AncestryChanged = NexusEventCreator:CreateEvent()
	table.insert(self.__EventsToClear,self.AncestryChanged)
	self.ChildAdded = NexusEventCreator:CreateEvent()
	table.insert(self.__EventsToClear,self.ChildAdded)
	self.ChildRemoved = NexusEventCreator:CreateEvent()
	table.insert(self.__EventsToClear,self.ChildRemoved)
	self.DescendantAdded = NexusEventCreator:CreateEvent()
	table.insert(self.__EventsToClear,self.DescendantAdded)
	self.DescendantRemoving = NexusEventCreator:CreateEvent()
	table.insert(self.__EventsToClear,self.DescendantRemoving)
	
	--Set up changed property tracking.
	self.__ChangedProperties = {}
	table.insert(self.__ConnectionsToClear,self.Changed:Connect(function(Property)
		self.__ChangedProperties[Property] = self[Property]
	end))
	
	--Set up parent changes.
	self:__InitParentChanges()
end

--[[
Initializes changes to teh parent structure.
--]]
function NexusContainer:__InitParentChanges()
	--Set self as the root object.
	self = self.object
	
	--Set up changing the parent.
	local LastParent,LastAncestryChangedEvent
	table.insert(self.__ConnectionsToClear,self:GetPropertyChangedSignal("Parent"):Connect(function()
		local NewParent = self.Parent
		
		--Disconnect the last event.
		if LastAncestryChangedEvent then
			LastAncestryChangedEvent:Disconnect()
			LastAncestryChangedEvent = nil
		end
		
		--Register the new parent.
		if NewParent and NewParent:IsA(CLASS_NAME) then
			NewParent:__ChildAdded(self)
			
			LastAncestryChangedEvent = NewParent.AncestryChanged:Connect(function(Child,Parent)
				self.AncestryChanged:Fire(Child,Parent)
			end)
		end
		
		--Unregister the old parent.
		if LastParent and LastParent:IsA(CLASS_NAME) then
			LastParent:__ChildRemoved(self)
		end
		
		--Fire the ancestry changed event.
		self.AncestryChanged:Fire(self,NewParent)
		
		--Set the last parent as the new parent.
		LastParent = NewParent
	end))
end

--[[
Returns the object as a string.
--]]
function NexusContainer:__tostring()
	return tostring(self.Name)
end

--[[
Returns the value for a custom index. If the second
value returned is true, it will force return the
returned value, even if it is nil. If not, regular
indexing will be used.
--]]
function NexusContainer:__getindex(IndexName,OriginalReturn)
	--Return a child if one exists.
	if OriginalReturn == nil and IndexName ~= "__Children" and IndexName ~= "Name" then
		for _,Child in pairs(self.__Children or {}) do
			if Child.Name == IndexName then
				return Child
			end
		end
	end
	
	--Return the parent.
	return NexusContainer.super.__getindex(self.super,IndexName,OriginalReturn)
end

--[[
Clones the properties to another object.
--]]
function NexusContainer:__CloneProperties(TargetContainer,InstanceMap)
	for Name,Value in pairs(self.__ChangedProperties) do
		if Name ~= "Parent" and string.sub(Name,1,2) ~= "__" then
			if typeof(Value) == "table" and Value.IsA and Value:IsA(CLASS_NAME) then
				TargetContainer[Name] = InstanceMap[Value] or Value
			else
				TargetContainer[Name] = Value
			end
		end
	end
end

--[[
Returns a pre-initialized clone. Only the constructor
should be run with all properties added afterwards
except those starting with "__".
--]]
function NexusContainer:__PreInitializeClone()
	return NexusContainer.new()
end

--[[
Recursively clones the instance and
returns the new instance and a map of the
old instances to the new ones.
--]]
function NexusContainer:__RecursiveClone()
	--Return if Archivable is false.
	if self.Archivable == false then
		return nil,{}
	end
	
	--Clone the instance.
	local InstanceMap = {}
	local NewContainer = self:__PreInitializeClone()
	InstanceMap[self] = NewContainer
	
	--Clone the children.
	for _,Child in pairs(self:GetChildren()) do
		--Throw an error if the child already exists.
		if InstanceMap[Child] then
			error("Structure is recursive. Cloning will not work.")
		end
		
		--Add the clone.
		local Clone,CloneMap = Child:__RecursiveClone()
		if Clone then
			Clone.Parent = NewContainer 
		end
		
		--Add the mirror instances.
		for OldInstance,NewInstance in pairs(CloneMap) do
			InstanceMap[OldInstance] = NewInstance
		end
	end
	
	--Return the new instance and the map.
	return NewContainer,InstanceMap
end

--[[
Invoked when a child is added.
--]]
function NexusContainer:__ChildAdded(Child)
	--Return if the child exists.
	for i,OtherChild in pairs(self.__Children) do
		if Child == OtherChild then
			return
		end
	end
	
	--Add the child.
	table.insert(self.__Children,Child)
	
	--Fire the events.
	if not Child.Hidden then
		self.ChildAdded:Fire(Child)
		self.DescendantAdded:Fire(Child)
	end
	
	--Set up the descendant events for the child.
	local ChildDescendantAddedEvent = Child.DescendantAdded:Connect(function(OtherChild)
		if not Child.Hidden then
			self.DescendantAdded:Fire(OtherChild)
		end
	end)
	local ChildDescendantRemovingEvent = Child.DescendantRemoving:Connect(function(OtherChild)
		if not Child.Hidden then
			self.DescendantRemoving:Fire(OtherChild)
		end
	end)
	
	self.__DescendantEvents[Child] = {ChildDescendantAddedEvent,ChildDescendantRemovingEvent}
end

--[[
Invoked when a child is removed.
--]]
function NexusContainer:__ChildRemoved(Child)
	--Remove the child.
	local IndexToRemove 
	for i,OtherChild in pairs(self.__Children) do
		if Child == OtherChild then
			IndexToRemove = i
		end
	end
	if IndexToRemove then
		table.remove(self.__Children,IndexToRemove)
	end
	
	--Fire the events.
	if not Child.Hidden then
		self.ChildRemoved:Fire(Child)
		self.DescendantRemoving:Fire(Child)
		
		--Fire the DescendantRemoving for the children.
		for _,SubChild in pairs(Child:GetDescendants()) do
			self.DescendantRemoving:Fire(SubChild)
		end
	end
	
	--Disconnect the child descendant events.
	local ChildEvents = self.__DescendantEvents[Child]
	if ChildEvents then
		for _,Event in pairs(ChildEvents) do
			Event:Disconnect()
		end
		
		self.__DescendantEvents[Child] = nil
	end
end

--[[
This function destroys all of an NexusContainer's children.
--]]
function NexusContainer:ClearAllChildren()
	--Destroy the children.
	for _,Child in pairs(self:GetChildren()) do
		Child:Destroy()
	end
end

--[[
Create a deep copy of a NexusContainer and
descendants where Archivable = true.
--]]
function NexusContainer:Clone()
	--Return if Archivable is false.
	if self.Archivable == false then
		return
	end
	
	--Clone the instances.
	local NewInstance,InstanceMap = self:__RecursiveClone()
	
	--Apply the properties.
	for OldInstance,NewInstance in pairs(InstanceMap) do
		OldInstance:__CloneProperties(NewInstance,InstanceMap)
	end
	
	--Return the new container.
	return NewInstance
end

--[[
Sets the NexusContainer.Parent property to nil,
locks the NexusContainer.Parent property,
and calls Destroy on all children.
--]]
function NexusContainer:Destroy()
	--Set the parent to nil and lock the property.
	self.Parent = nil
	self:LockProperty("Parent")
	
	--Disconnect the events.
	for _,Event in pairs(self.__EventsToClear) do
		Event:Disconnect()
	end
	for _,Connection in pairs(self.__ConnectionsToClear) do
		Connection:Disconnect()
	end
	self.__EventsToClear = {}
	self.__ConnectionsToClear = {}
	
	--Destroy the children.
	self:ClearAllChildren()
end

--[[
Returns the first ancestor of the NexusContainer
whose NexusContainer.Name is equal to the given
name.
--]]
function NexusContainer:FindFirstAncestor(Name)
	--Return nil if the parent is nil.
	if self.Parent == nil then
		return nil
	end
	
	--Return the parent if the parent matches the name.
	local Parent = self.Parent
	if Parent.Name == Name then
		return Parent
	end
	
	--Return the parent.
	return Parent:FindFirstAncestor(Name)
end

--[[
Returns the first ancestor of the NexusContainer
whose NexusContainer.ClassName is equal to the
given className.
--]]
function NexusContainer:FindFirstAncestorOfClass(ClassName)
	--Return nil if the parent is nil.
	if self.Parent == nil then
		return nil
	end
	
	--Return the parent if the parent matches the class name.
	local Parent = self.Parent
	if Parent.ClassName == ClassName then
		return Parent
	end
	
	--Return the parent.
	return Parent:FindFirstAncestorOfClass(ClassName)
end

--[[
Returns the first ancestor of the NexusContainer for whom
NexusContainer:IsA returns true for the given ClassName.
--]]
function NexusContainer:FindFirstAncestorWhichIsA(ClassName)
	--Return nil if the parent is nil.
	if self.Parent == nil then
		return nil
	end
	
	--Return the parent if the parent matches the class name.
	local Parent = self.Parent
	if Parent:IsA(ClassName) then
		return Parent
	end
	
	--Return the parent.
	return Parent:FindFirstAncestorWhichIsA(ClassName)
end

--[[
Returns the first child of the NexusContainer found with
the given name.
--]]
function NexusContainer:FindFirstChild(Name,Recursive)
	--Return if a direct child has the name.
	for _,Child in pairs(self:GetChildren()) do
		if Child.Name == Name then
			return Child
		end
	end
	
	--If it is recursive, return a subchild.
	if Recursive then
		for _,Child in pairs(self:GetChildren()) do
			local Match = Child:FindFirstChild(Name,Recursive)
			if Match then
				return Match
			end
		end
	end
end

--[[
Returns the first child of the NexusContainer whose ClassName
is equal to the given ClassName.
--]]
function NexusContainer:FindFirstChildOfClass(ClassName)
	--Return if a direct child has the class name.
	for _,Child in pairs(self:GetChildren()) do
		if Child.ClassName == ClassName then
			return Child
		end
	end
end

--[[
Returns the first child of the NexusContainer for whom 
NexusContainer:IsA returns true for the given ClassName.
--]]
function NexusContainer:FindFirstChildWhichIsA(ClassName,Recursive)
	--Return if a direct child has the class.
	for _,Child in pairs(self:GetChildren()) do
		if Child:IsA(ClassName) then
			return Child
		end
	end
	
	--If it is recursive, return a subchild.
	if Recursive then
		for _,Child in pairs(self:GetChildren()) do
			local Match = Child:FindFirstChildWhichIsA(ClassName,Recursive)
			if Match then
				return Match
			end
		end
	end
end

--[[
Returns an array containing all of the NexusContainers's
children.
--]]
function NexusContainer:GetChildren()
	local Children = {}
	
	--Clone the non-hidden children table.
	for _,Child in pairs(self.__Children) do
		if not Child.Hidden then
			table.insert(Children,Child)
		end
	end
	
	--Return the children.
	return Children
end

--[[
Returns an array containing all of the descendants of the
NexusContainer.
--]]
function NexusContainer:GetDescendants()
	local Children = {}
	
	--Add the children and descendants.
	for _,Child in pairs(self.__Children) do
		if not Child.Hidden then
			table.insert(Children,Child)
			for _,SubChild in pairs(Child:GetDescendants()) do
				table.insert(Children,SubChild)
			end
		end
	end
	
	--Return the children.
	return Children
end

--[[
Returns a string describing the NexusContainer's ancestry.
--]]
function NexusContainer:GetFullName()
	if self.Parent then
		return self.Parent:GetFullName().."."..self.Name
	else
		return self.Name
	end
end

--[[
Returns true if an NexusContainer is an ancestor of the given
descendant.
--]]
function NexusContainer:IsAncestorOf(OtherContainer)
	--Return false if the parent is nil.
	if not OtherContainer or not OtherContainer.Parent then
		return false
	end
	
	--Return true if the parent is the false.
	if OtherContainer.Parent == self then
		return true
	end
	
	--Return if the parent is an ancestor.
	return self:IsAncestorOf(OtherContainer.Parent)
end

--[[
Returns true if an NexusContainer is a descendant of the given
ancestor.
--]]
function NexusContainer:IsDescendantOf(OtherContainer)
	--Return false if the parent is nil.
	if not OtherContainer or not self.Parent then
		return false
	end
	
	--Return true if the parent is the false.
	if self.Parent == OtherContainer then
		return true
	end
	
	--Return if the parent is an ancestor.
	return self.Parent:IsDescendantOf(OtherContainer)
end

--[[
Returns the child of the NexusContainer with the given name.
If the child does not exist, it will yield the current thread
until it does.
--]]
function NexusContainer:WaitForChild(Name,TimeOut)
	local StartTime = tick()
	local WarningDisplayed = false
	
	--Run the loop until it returns.
	while true do
		--Return if the patch exists.
		local Child = self:FindFirstChild(Name)
		if Child then
			return Child
		end
		
		--Handle a timeout or infinite yield.
		if TimeOut then
			if tick() - StartTime >= TimeOut then
				return nil
			end
		elseif not WarningDisplayed and tick() - StartTime >= INFINITE_YEILD_DELAY then
			WarningDisplayed = true
			warn("Infinite yield possible on '"..self:GetFullName()..":WaitForChild(\""..Name.."\")'")
		end
		wait()
	end
end

--[[
Connects an event to the highest parent. If the ancestry
changes, the connected event changes. Returns a connection. 
--]]
function NexusContainer:ConnectToHighestParent(EventName,ConnectionFunction)
	--Create the connection.
	local Connection = NexusConnection.new(nil,ConnectionFunction)
	local CurrentConnection
	
	--[[
	Attempts to connect the event to the object.
	--]]
	local function AttemptConnection(Object)
		--Connect the event.
		local Worked,Return = pcall(function()
			local Event = Object[EventName]
			if not Event then
				return false
			else
				CurrentConnection = Event:Connect(ConnectionFunction)
				return true
			end
		end)
		if Worked then return Return end
			
		--Return false (failed).
		return false
	end
	
	--[[
	Returns true if the parent was connected.
	--]]
	local function ConnectParent(Object)
		--Return false if the event is disconnected.
		if not Connection.Connected then
			return false
		end
		
		--Return false, attempt connecting.
		local Parent = Object.Parent
		if not Parent then
			return AttemptConnection(Object)
		end
		
		--Return if the parent was connected.
		if Parent and ConnectParent(Parent) then
			return true
		end
		
		--Connect the event.
		return AttemptConnection(Object)
	end
	
	self.AncestryChanged:Connect(function()
		--Disconnect the current connection.
		if CurrentConnection then
			CurrentConnection:Disconnect()
			CurrentConnection = nil
		end
		
		--Reconnect the event.
		ConnectParent(self)
	end)
	ConnectParent(self)
	
	--Return the connection.
	return Connection
end



return NexusContainer</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">NexusDisablableContainer</string>
              <string name="Source">--[[
TheNexusAvenger

Guarentees a container can be enabled or disabled.
--]]

local CLASS_NAME = "NexusDisablableContainer"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")

local NexusDisablableContainer = NexusContainer:Extend()
NexusDisablableContainer:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusDisablableContainer)



--[[
Creates a Nexus Disablable Container object.
--]]
function NexusDisablableContainer:__new()
	self:InitializeSuper()
	
	self.Name = CLASS_NAME
	self.Disabled = false
end

--[[
Returns if the container is enabled.
--]]
function NexusDisablableContainer:IsEnabled()
	return not self.Disabled
end



return NexusDisablableContainer</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">NexusWrappedInstance</string>
              <string name="Source">--[[
TheNexusAvenger

Wraps a Roblox Instance with the NexusContainer API.
--]]

local CLASS_NAME = "NexusWrappedInstance"

local INSTANCE_CREATION_PRESETS = {
	Frame = {
		BackgroundColor3 = "MainBackground",
		BorderColor3 = "Border",
		BorderSizePixel = 0,
	},
	TextLabel = {
		BackgroundTransparency = 1,
		TextColor3 = "MainText",
		TextXAlignment = "Left",
		Font = "SourceSans",
		TextSize = 14,
	},
	TextButton = {
		BackgroundColor3 = "Button",
		BorderColor3 = "ButtonBorder",
		BorderSizePixel = 1,
		TextColor3 = "ButtonText",
		Font = "SourceSans",
		TextSize = 14,
	},
	TextBox = {
		BackgroundColor3 = "InputFieldBackground",
		BorderColor3 = "InputFieldBorder",
		BorderSizePixel = 1,
		TextColor3 = "MainText",
		PlaceholderColor3 = "DimmedText",
		TextXAlignment = "Left",
		Font = "SourceSans",
		TextSize = 14,
		ClearTextOnFocus = false,
		ClipsDescendants = true,
	}
}



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusDisablableContainer = NexusPluginFramework:GetResource("Base.NexusDisablableContainer")
local NexusPlugin = NexusPluginFramework:GetResource("Plugin.NexusPlugin")
local NexusSettings = NexusPluginFramework:GetResource("Plugin.NexusSettings")

local NexusWrappedInstance = NexusDisablableContainer:Extend()
NexusWrappedInstance:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusWrappedInstance)

local ReadOnlyProperties = {}
local Settings = NexusSettings.GetSettings()

local CachedInstances = {}
setmetatable(CachedInstances,{__mode="v"})
NexusWrappedInstance.CachedInstances = CachedInstances



--[[
Replaces an instance or table of instances with 
wrapped instances.
--]]
local function ReplaceInstances(InstanceOrTable)
	--Replace the Instance if it is an instance.
	if typeof(InstanceOrTable) == "Instance" then
		return NexusWrappedInstance.GetInstance(InstanceOrTable)
	end
	
	--Replace parts of the table if it is a table.
	if typeof(InstanceOrTable) == "table" then
		for Key,Value in pairs(InstanceOrTable) do
			InstanceOrTable[Key] = ReplaceInstances(Value)
		end
	end
	
	--Return the original type.
	return InstanceOrTable
end

--[[
Unwraps a NexusContainer or table of NexusContainers with 
unwrapped instances.
--]]
local function UnwrapInstances(ContainerOrTable)
	--Replace parts of the table if it is a table or unwrap the instance if it is a container.
	if typeof(ContainerOrTable) == "table" then
		if ContainerOrTable.IsA and ContainerOrTable:IsA(CLASS_NAME) then
			return ContainerOrTable:GetWrappedInstance()
		else
			for Key,Value in pairs(ContainerOrTable) do
				ContainerOrTable[Key] = UnwrapInstances(Value)
			end
		end
	end
	
	--Return the original type.
	return ContainerOrTable
end



--[[
Gets a Nexus Wrapped Instance.
--]]
function NexusWrappedInstance.GetInstance(ExistingInstance)
	--Create the string instance or create the cached instance if needed.
	local CachedInstance = CachedInstances[ExistingInstance]
	if typeof(ExistingInstance) == "string" then
		CachedInstance = NexusWrappedInstance.new(ExistingInstance)
		CachedInstances[CachedInstance:GetWrappedInstance()] = CachedInstance
	else
		if not CachedInstance then
			CachedInstance = NexusWrappedInstance.new(ExistingInstance)
			CachedInstances[ExistingInstance] = CachedInstance
		end
	end
	
	--Return the cached entry.
	return CachedInstance
end



--[[
Creates a Nexus Wrapped Instance object.
--]]
function NexusWrappedInstance:__new(ExistingInstance)
	self:InitializeSuper()
	
	--Convert the ExistingInstance if it is a string.
	local AddDefaults = false
	if typeof(ExistingInstance) == "string" then
		ExistingInstance = Instance.new(ExistingInstance)
		AddDefaults = true
	end
	
	--Initialize the class.
	self.__ReferenceInstance = ExistingInstance
	self.__ChangeFunctions = {}
	self.__ColorProperties = {}
	self.__IgnoreChangesQueue = {}
	self.__IgnoreReverseChangesQueue = {}
	self.__NoBackwardsReplicationProperties = {}
	self.Name = ExistingInstance.Name
	
	--Register the wrapped instance.
	if not CachedInstances[ExistingInstance] then
		CachedInstances[ExistingInstance] = self
	end
	
	--Set up changes to Hidden not affecting anything.
	self:__SetChangedOverride("Hidden",function() end)
	
	--[[
	Returns the current color modifier.
	--]]
	local function GetColorModifier()
		if not self:IsEnabled() then
			return Enum.StudioStyleGuideModifier.Disabled
		elseif self.Selected then
			return Enum.StudioStyleGuideModifier.Selected
		else
			return Enum.StudioStyleGuideModifier.Default
		end
	end
	
	--[[
	Updates a color property.
	--]]
	local function UpdateColorProperty(PropertyName)
		local Theme = Settings:GetSetting("Studio","Theme")
		local Color = self[PropertyName]
		
		--Set the color.
		self.__IgnoreChangesQueue[PropertyName] = true
		if type(Color) == "string" or typeof(Color) == "EnumItem" then
			local ColorModifier = GetColorModifier()
			ExistingInstance[PropertyName] = Theme:GetColor(Color,ColorModifier)
		else
			ExistingInstance[PropertyName] = Color
		end
	end
	
	--[[
	Updates all of the color properties.
	--]]
	local function UpdateAllColorProperties()
		for ColorPropertyName,_ in pairs(self.__ColorProperties) do
			UpdateColorProperty(ColorPropertyName)
		end
	end
	
	--Set up changing the colors when the setting changes.
	table.insert(self.__ConnectionsToClear,settings()["Studio"].ThemeChanged:Connect(UpdateAllColorProperties))
	
	--Set up changing colors when enabled/disabled and selected/deselected.
	self:__SetChangedOverride("Disabled",UpdateAllColorProperties)
	self:__SetChangedOverride("Selected",UpdateAllColorProperties)
	
	--Mirror changes to the wrapped object.
	local ChangedFunctions = self.__ChangeFunctions
	local ColorProperties = self.__ColorProperties
	local IgnoreReverseChangesQueue = self.__IgnoreReverseChangesQueue
	local IgnoreChangesQueue = self.__IgnoreChangesQueue
	local NoBackwardsReplicationProperties = self.__NoBackwardsReplicationProperties
	local RawGet = self.__rawget
	self:AddGenericPropertyFinalizer(function(PropertyName,NewProperty)
		--If an overriden change function exists, call it.
		local ChangedFunction = ChangedFunctions[PropertyName]
		if ChangedFunction then
			ChangedFunction()
			return
		end
		
		--If a property was replicated to here, return.
		if IgnoreReverseChangesQueue[PropertyName] then
			IgnoreReverseChangesQueue[PropertyName] = nil
			return
		end
		
		--Mirror the property.
		if string.sub(PropertyName,1,2) ~= "__" then
			local ExistingProperty = ExistingInstance[PropertyName]
			local ExistingPropertyType = typeof(ExistingProperty)
			local NewPropertyType = typeof(NewProperty)
			
			if ExistingPropertyType == "Color3" then
				ColorProperties[PropertyName] = true
				UpdateColorProperty(PropertyName)
			elseif (ExistingPropertyType == "Instance" or ExistingProperty == nil) and (NewPropertyType == "table" and NewProperty.IsA and NewProperty:IsA(CLASS_NAME)) then
				IgnoreChangesQueue[PropertyName] = true
				ExistingInstance[PropertyName] = NewProperty:GetWrappedInstance()
			else
				IgnoreChangesQueue[PropertyName] = true
				ExistingInstance[PropertyName] = NewProperty
			end
		end
	end)
	
	--Mirror changes from the instance.
	table.insert(self.__ConnectionsToClear,ExistingInstance.Changed:Connect(function(PropertyName)
		if not ReadOnlyProperties[PropertyName] and not NoBackwardsReplicationProperties[PropertyName] then
			--Wrap the error.
			pcall(function()
				--Set the changed property or fire a changed signal.
				local ExistingValue,NewValue = self[PropertyName],ExistingInstance[PropertyName]
				if not IgnoreChangesQueue[PropertyName] or (ExistingValue ~= NewValue and typeof(ExistingValue) == typeof(NewValue)) then
					IgnoreChangesQueue[PropertyName] = nil
					IgnoreReverseChangesQueue[PropertyName] = true
					
					--Change the property or fire the changed signals if there is no changes.
					if ExistingValue ~= NewValue then
						self[PropertyName] = NewValue
					else
						self.Changed:Fire(PropertyName)
						self:GetPropertyChangedSignal(PropertyName):Fire()
					end
				end
			end)
		end
	end))
	
	--Set the selected property to be false.
	self.Selected = false
	
	--Set the defaults.
	if AddDefaults then
		local Defaults = INSTANCE_CREATION_PRESETS[ExistingInstance.ClassName]
		if Defaults then
			for Key,Property in pairs(Defaults) do
				self[Key] = Property
			end
		end
	end
end

--[[
Returns the value for a custom index. If the second
value returned is true, it will force return the
returned value, even if it is nil. If not, regular
indexing will be used.
--]]
function NexusWrappedInstance:__getindex(IndexName,OriginalReturn)
	--Return a passed-through property.
	if OriginalReturn == nil and IndexName ~= "__ReferenceInstance" then
		local Worked,Return = pcall(function()
			local ReferenceInstance = self.__ReferenceInstance
			local Return = ReferenceInstance[IndexName]
			local NewReturn = ReplaceInstances(Return)
			
			--Modify the return if it is a function or a Roblox Instance.
			if type(Return) == "function" then
				NewReturn = function(...)
					--Unwrap the instances.
					local Arguments = {...}
					Arguments = UnwrapInstances(Arguments)
					
					--Run the method and replace the instances.
					local MethodReturn = {Return(unpack(Arguments))}
					MethodReturn = ReplaceInstances(MethodReturn)
					
					--Unpack the return.
					return unpack(MethodReturn)
				end
			end
			
			--Return the Instance return.
			return NewReturn
		end)
		
		--Return the result if there was no error (was able to index the Instance).
		if Worked then
			return Return,true
		end
	end
	
	--Return the parent.
	return NexusWrappedInstance.super:__getindex(IndexName,OriginalReturn)
end

--[[
Returns a pre-initialized clone. Only the constructor
should be run with all properties added afterwards
except those starting with "__".
--]]
function NexusWrappedInstance:__PreInitializeClone()
	return NexusWrappedInstance.new(self:GetWrappedInstance():Clone())
end

--[[
Adds an change overrider that prevents mirroring to
the wrapped instance.
--]]
function NexusWrappedInstance:__SetChangedOverride(PropertyName,Function)
	self.__ChangeFunctions[PropertyName] = Function
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusWrappedInstance:IsA(ClassName)
	return self.ClassName == ClassName or self.super:IsA(ClassName) or self:GetWrappedInstance():IsA(ClassName)
end

--[[
Returns the wrapped instance.
--]]
function NexusWrappedInstance:GetWrappedInstance()
	return self.__ReferenceInstance
end

--[[
Sets the NexusContainer.Parent property to nil,
locks the NexusContainer.Parent property,
and calls Destroy on all children.
--]]
function NexusWrappedInstance:Destroy()
	self.super:Destroy()
	
	local Ins = self:GetWrappedInstance()
	if Ins then
		Ins:Destroy()
	end
end



return NexusWrappedInstance</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="11">
            <Properties>
              <string name="Name">OverridableIndexInstance</string>
              <string name="Source">--[[
TheNexusAvenger

Extends Nexus Instance to allow lower level overriding of indexing.
--]]

local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusInstance = NexusPluginFramework:GetResource("NexusInstance.NexusInstance")

local OverridableIndexInstance = NexusInstance:Extend()
OverridableIndexInstance:SetClassName("OverridableIndexInstance")
NexusPluginFramework:SetContextResource(OverridableIndexInstance)



--[[
Creates an instance of a Nexus Instance.
--]]
function OverridableIndexInstance:__new()
	--Set up the base object.
	self:InitializeSuper()
	
	--Get the base index method.
	local Metatable = getmetatable(self.object)
	local ExistingNewIndex = Metatable.__newindex
	
	--Get the new index method.
	local CustomNewIndexFunction = self.object["__setindex"]
	
	--Set up custom new indexing.
	Metatable.__newindex = function(_,Index,NewValue)
		--Get the new value.
		if CustomNewIndexFunction then
			NewValue = CustomNewIndexFunction(self.object,Index,NewValue)
		end
		
		--Set the value.
		ExistingNewIndex(self.object,Index,NewValue)
	end
end

--[[
Creates an __index metamethod for an object.
--]]
function OverridableIndexInstance:__createindexmethod(Object,Class,RootClass)
	if not RootClass then RootClass = Class end
	
	--Get the base method.
	local BaseIndexMethod = NexusInstance:__createindexmethod(Object,Class,RootClass)
	local CustomIndexFunction = RootClass.__getindex
	
	--Return a wrapped method.
	return function(MethodObject,Index)
		--Return the base meta method.
		if Index == "BaseIndexMetaMethod" then
			return BaseIndexMethod
		end
		
		--Return a custom index.
		local BaseIndex = BaseIndexMethod(self,Index)
		if CustomIndexFunction and Index ~= "super" then
			local CustomIndex,ForceNil = CustomIndexFunction(Object,Index,BaseIndex)
			if ForceNil == true or CustomIndex ~= nil then
				return CustomIndex
			end
		end
		
		--Return the base index.
		return BaseIndex
	end
end

--[[
Returns the raw index of the object (bypasses __getindex).
--]]
function OverridableIndexInstance:__rawget(Index)
	return self.BaseIndexMetaMethod(self,Index)
end

--[[
Returns the value for a custom index. If the second
value returned is true, it will force return the
returned value, even if it is nil. If not, regular
indexing will be used.
--]]
function OverridableIndexInstance:__getindex(IndexName,OriginalReturn)
	return nil,false
end

--[[
Returns the value for an index to be set. This is
run before the value of the object is set.
--]]
function OverridableIndexInstance:__setindex(IndexName,NewValue)
	return NewValue
end



return OverridableIndexInstance</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="12">
          <Properties>
            <string name="Name">Data</string>
          </Properties>
          <Item class="Folder" referent="13">
            <Properties>
              <string name="Name">Enum</string>
            </Properties>
            <Item class="ModuleScript" referent="14">
              <Properties>
                <string name="Name">NexusEnum</string>
                <string name="Source">--[[
TheNexusAvenger

Custom enum that contains a set of items, including Enums.
--]]

local CLASS_NAME = "NexusEnum"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local OverridableIndexInstance = NexusPluginFramework:GetResource("Base.OverridableIndexInstance")

local NexusEnum = OverridableIndexInstance:Extend()
NexusEnum:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusEnum)



--[[
Creates an NexusEnum object.
--]]
function NexusEnum:__new(Name)
	self:InitializeSuper()
	
	self.Name = Name
	self.CustomEnums = {}
end

--[[
Returns the value for a custom index. If the second
value returned is true, it will force return the
returned value, even if it is nil. If not, regular
indexing will be used.
--]]
function NexusEnum:__getindex(IndexName,OriginalReturn)
	--Return the base case for CustomEnums.
	if IndexName == "CustomEnums" then
		return OriginalReturn
	end
	
	--Return an enum item.
	local CustomEnums = self.CustomEnums
	if CustomEnums then
		local CustomEnum = CustomEnums[IndexName]
		if CustomEnum then
			return CustomEnum,true
		end
	end
	
	--Return the super.
	return NexusEnum.super.__getindex(self,IndexName,OriginalReturn)
end

--[[
Returns the Enum as a string.
--]]
function NexusEnum:__tostring()
	--Create the base.
	local Base = ""
	if self.ParentEnum ~= nil then
		Base = tostring(self.ParentEnum).."."
	end
	
	--Return the string.
	return Base..self.Name
end

--[[
Returns an enum for the name.
--]]
function NexusEnum:GetEnum(EnumName)
	return self.CustomEnums[EnumName]
end

--[[
Returns a list of the sub-enums.
--]]
function NexusEnum:GetEnumItems()
	--Clone the enum items.
	local ClonedSubEnums = {}
	for _,SubEnum in pairs(self.CustomEnums) do
		table.insert(ClonedSubEnums,SubEnum)
	end
	
	--Return the enum items.
	return ClonedSubEnums
end

--[[
Adds an Enum.
--]]
function NexusEnum:AddEnum(EnumInstance)
	self.CustomEnums[EnumInstance.Name] = EnumInstance
	EnumInstance.ParentEnum = self
end

--[[
Creates an Enum.
--]]
function NexusEnum:CreateEnum(...)
	local Names = {...}
	
	--Add or create the enum.
	local CurrentEnum = self
	for _,Name in pairs(Names) do
		--Create a new enum.
		if not CurrentEnum:GetEnum(Name) then
			local NewEnum = NexusEnum.new(Name)
			CurrentEnum:AddEnum(NewEnum)
		end
		
		--Move the current enum.
		CurrentEnum = CurrentEnum:GetEnum(Name)
	end
	
	--Return the enum.
	return CurrentEnum
end

--[[
Returns if another enum item is equal.
--]]
function NexusEnum:Equals(OtherEnum)
	return self == OtherEnum or self.Name == OtherEnum or tostring(self) == tostring(OtherEnum)
end



return NexusEnum</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="15">
              <Properties>
                <string name="Name">NexusEnumCollection</string>
                <string name="Source">--[[
TheNexusAvenger

Contains a set of Enums and can reference Roblox enums.
--]]

local CLASS_NAME = "NexusEnumCollection"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusEnum = NexusPluginFramework:GetResource("Data.Enum.NexusEnum")

local NexusEnumCollection = NexusEnum:Extend()
NexusEnumCollection:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusEnumCollection)

local StaticInstance



--[[
Returns a static instance with a set of built-in
enums used by the framework.
--]]
function NexusEnumCollection.GetBuiltInEnums()
	--Create the static instance.
	if not StaticInstance then
		StaticInstance = NexusEnumCollection.new()
		
		--Add the enums.
		StaticInstance:CreateEnum("NexusScrollTheme","Native")
		StaticInstance:CreateEnum("NexusScrollTheme","Qt5")
		StaticInstance:CreateEnum("CheckBoxState","Checked")
		StaticInstance:CreateEnum("CheckBoxState","Unchecked")
		StaticInstance:CreateEnum("CheckBoxState","Mixed")
	end
	
	--Return the static instance.
	return StaticInstance
end

--[[
Creates an NexusEnumCollection object.
--]]
function NexusEnumCollection:__new()
	self:InitializeSuper("NexusEnum")
end

--[[
Returns the value for a custom index. If the second
value returned is true, it will force return the
returned value, even if it is nil. If not, regular
indexing will be used.
--]]
function NexusEnumCollection:__getindex(IndexName,OriginalReturn)
	--Return the base case for CustomEnums.
	if IndexName == "CustomEnums" then
		return OriginalReturn
	end
	
	--Return an enum item.
	local CustomEnums = self.CustomEnums
	if CustomEnums then
		local CustomEnum = CustomEnums[IndexName]
		if CustomEnum then
			return CustomEnum,true
		end
	end
	
	--Return a Roblox enum.
	local Worked,Return = pcall(function()
		return Enum[IndexName]
	end)
	
	if Worked then
		return Return
	end
	
	--Return the super.
	return NexusEnumCollection.super.__getindex(self,IndexName,OriginalReturn)
end



return NexusEnumCollection</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="16">
            <Properties>
              <string name="Name">ThemeColors</string>
              <string name="Source">--[[
TheNexusAvenger

Data containing the theme colors if it isn't in a plugin context.
--]]



--[[
--Use the following function for print a list of all the colors:

print("return {")
for _,ColorEnum in pairs(Enum.StudioStyleGuideColor:GetEnumItems()) do
	print("\t[\""..string.sub(tostring(ColorEnum),28).."\"] = {")
	for _,ModifierEnum in pairs(Enum.StudioStyleGuideModifier:GetEnumItems()) do
		print("\t\t["..tostring(ModifierEnum).."] = Color3.new("..tostring(settings()["Studio"].Theme:GetColor(ColorEnum,ModifierEnum)).."),")
	end
	print("\t},")
end
print("}")
--]]



return {
	["MainBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["Titlebar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["Dropdown"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["Tooltip"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["Notification"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["ScrollBar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.219608, 0.219608, 0.219608),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.219608, 0.219608, 0.219608),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.27451, 0.27451, 0.27451),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.27451, 0.27451, 0.27451),
	},
	["ScrollBarBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.160784, 0.160784, 0.160784),
	},
	["TabBar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["Tab"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.164706, 0.164706, 0.164706),
	},
	["FilterButtonDefault"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["FilterButtonHover"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["FilterButtonChecked"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.109804, 0.109804, 0.109804),
	},
	["FilterButtonAccent"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["FilterButtonBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["FilterButtonBorderAlt"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["RibbonTab"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["RibbonTabTopBar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.709804, 1),
	},
	["Button"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0, 0.635294, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["MainButton"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0, 0.635294, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0, 0.635294, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0, 0.454902, 0.741176),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0, 0.635294, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.196078, 0.709804, 1),
	},
	["RibbonButton"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.109804, 0.109804, 0.109804),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["ViewPortBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["InputFieldBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["Item"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["TableItem"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["CategoryItem"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["GameSettingsTableItem"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.164706, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["GameSettingsTooltip"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["EmulatorBar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["EmulatorDropDown"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["ColorPickerFrame"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["CurrentMarker"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["Border"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["Shadow"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.25098, 0.25098, 0.25098),
	},
	["Light"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.25098, 0.25098, 0.25098),
	},
	["Dark"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["Mid"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["MainText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 1, 1),
	},
	["SubText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
	["TitlebarText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
	["BrightText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.898039, 0.898039, 0.898039),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.898039, 0.898039, 0.898039),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.898039, 0.898039, 0.898039),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.898039, 0.898039, 0.898039),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.898039, 0.898039, 0.898039),
	},
	["DimmedText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.4, 0.4, 0.4),
	},
	["LinkText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.709804, 1),
	},
	["WarningText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.556863, 0.235294),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.556863, 0.235294),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.556863, 0.235294),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.556863, 0.235294),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.556863, 0.235294),
	},
	["ErrorText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.266667, 0.266667),
	},
	["InfoText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.501961, 0.843137, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.501961, 0.843137, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.501961, 0.843137, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.501961, 0.843137, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.501961, 0.843137, 1),
	},
	["SensitiveText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.819608, 0.364706, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.819608, 0.364706, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.819608, 0.364706, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.819608, 0.364706, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.819608, 0.364706, 1),
	},
	["ScriptSideWidget"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["ScriptBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["ScriptText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["ScriptSelectionText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 1, 1),
	},
	["ScriptSelectionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.0431373, 0.352941, 0.686275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.0431373, 0.352941, 0.686275),
	},
	["ScriptFindSelectionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.552941, 0.462745, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.552941, 0.462745, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.552941, 0.462745, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.552941, 0.462745, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.552941, 0.462745, 0),
	},
	["ScriptMatchingWordSelectionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.333333, 0.333333, 0.333333),
	},
	["ScriptOperator"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["ScriptNumber"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.776471, 0),
	},
	["ScriptString"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.678431, 0.945098, 0.584314),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.678431, 0.945098, 0.584314),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.678431, 0.945098, 0.584314),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.678431, 0.945098, 0.584314),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.678431, 0.945098, 0.584314),
	},
	["ScriptComment"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.4, 0.4, 0.4),
	},
	["ScriptKeyword"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.972549, 0.427451, 0.486275),
	},
	["ScriptBuiltInFunction"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.517647, 0.839216, 0.968628),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.517647, 0.839216, 0.968628),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.517647, 0.839216, 0.968628),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.517647, 0.839216, 0.968628),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.517647, 0.839216, 0.968628),
	},
	["ScriptWarning"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.45098, 0.0823529),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.45098, 0.0823529),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.45098, 0.0823529),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.45098, 0.0823529),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.45098, 0.0823529),
	},
	["ScriptError"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0, 0),
	},
	["ScriptWhitespace"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.333333, 0.333333, 0.333333),
	},
	["ScriptRuler"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.4, 0.4, 0.4),
	},
	["DebuggerCurrentLine"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.164706, 0.235294, 0.298039),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.164706, 0.235294, 0.298039),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.164706, 0.235294, 0.298039),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.164706, 0.235294, 0.298039),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.164706, 0.235294, 0.298039),
	},
	["DebuggerErrorLine"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.298039, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.298039, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.298039, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.298039, 0.164706, 0.164706),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.298039, 0.164706, 0.164706),
	},
	["ScriptEditorCurrentLine"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.176471, 0.196078, 0.254902),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.176471, 0.196078, 0.254902),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.176471, 0.196078, 0.254902),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.176471, 0.196078, 0.254902),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.176471, 0.196078, 0.254902),
	},
	["DiffFilePathText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
	["DiffTextHunkInfo"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
	["DiffTextNoChange"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["DiffTextAddition"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["DiffTextDeletion"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["DiffTextSeparatorBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.192157, 0.223529, 0.286275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.192157, 0.223529, 0.286275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.192157, 0.223529, 0.286275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.192157, 0.223529, 0.286275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.192157, 0.223529, 0.286275),
	},
	["DiffTextNoChangeBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.105882, 0.121569, 0.12549),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.105882, 0.121569, 0.12549),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.105882, 0.121569, 0.12549),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.105882, 0.121569, 0.12549),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.105882, 0.121569, 0.12549),
	},
	["DiffTextAdditionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.188235, 0.247059, 0.172549),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.188235, 0.247059, 0.172549),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.188235, 0.247059, 0.172549),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.188235, 0.247059, 0.172549),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.188235, 0.247059, 0.172549),
	},
	["DiffTextDeletionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.282353, 0.117647, 0.0941177),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.282353, 0.117647, 0.0941177),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.282353, 0.117647, 0.0941177),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.282353, 0.117647, 0.0941177),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.282353, 0.117647, 0.0941177),
	},
	["DiffLineNum"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
	["DiffLineNumSeparatorBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.235294, 0.32549, 0.482353),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.235294, 0.32549, 0.482353),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.235294, 0.32549, 0.482353),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.235294, 0.32549, 0.482353),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.235294, 0.32549, 0.482353),
	},
	["DiffLineNumNoChangeBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.105882, 0.12549, 0.137255),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.105882, 0.12549, 0.137255),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.105882, 0.12549, 0.137255),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.105882, 0.12549, 0.137255),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.105882, 0.12549, 0.137255),
	},
	["DiffLineNumAdditionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.215686, 0.301961, 0.192157),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.215686, 0.301961, 0.192157),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.215686, 0.301961, 0.192157),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.215686, 0.301961, 0.192157),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.215686, 0.301961, 0.192157),
	},
	["DiffLineNumDeletionBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.356863, 0.133333, 0.105882),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.356863, 0.133333, 0.105882),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.356863, 0.133333, 0.105882),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.356863, 0.133333, 0.105882),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.356863, 0.133333, 0.105882),
	},
	["DiffFilePathBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["DiffFilePathBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["ChatIncomingBgColor"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.917647, 0.917647, 0.917647),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.917647, 0.917647, 0.917647),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.917647, 0.917647, 0.917647),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.917647, 0.917647, 0.917647),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.917647, 0.917647, 0.917647),
	},
	["ChatIncomingTextColor"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.223529, 0.231373, 0.239216),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.223529, 0.231373, 0.239216),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.223529, 0.231373, 0.239216),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.223529, 0.231373, 0.239216),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.223529, 0.231373, 0.239216),
	},
	["ChatOutgoingBgColor"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["ChatOutgoingTextColor"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["ChatModeratedMessageColor"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.266667, 0.266667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.266667, 0.266667),
	},
	["Separator"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["ButtonBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.207843, 0.207843),
	},
	["ButtonText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["InputFieldBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.101961, 0.101961, 0.101961),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.101961, 0.101961, 0.101961),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.258824, 0.258824, 0.258824),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.227451, 0.227451, 0.227451),
	},
	["CheckedFieldBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.145098, 0.145098, 0.145098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.145098, 0.145098, 0.145098),
	},
	["CheckedFieldBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.101961, 0.101961, 0.101961),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.101961, 0.101961, 0.101961),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.101961, 0.101961, 0.101961),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.25098, 0.25098, 0.25098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.227451, 0.227451, 0.227451),
	},
	["CheckedFieldIndicator"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.207843, 0.709804, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.333333, 0.333333, 0.333333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.207843, 0.709804, 1),
	},
	["HeaderSection"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.160784, 0.160784, 0.160784),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.207843, 0.207843, 0.207843),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.282353, 0.282353, 0.282353),
	},
	["Midlight"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.133333, 0.133333, 0.133333),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.133333, 0.133333, 0.133333),
	},
	["StatusBar"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.180392, 0.180392, 0.180392),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.180392, 0.180392, 0.180392),
	},
	["DialogButton"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.2, 0.2, 0.2),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.2, 0.2, 0.2),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.258824, 0.258824, 0.258824),
	},
	["DialogButtonText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["DialogButtonBorder"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.235294, 0.235294, 0.235294),
	},
	["DialogMainButton"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0, 0.635294, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0, 0.454902, 0.741176),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0, 0.454902, 0.741176),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.235294, 0.235294, 0.235294),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.196078, 0.709804, 1),
	},
	["DialogMainButtonText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 1, 1),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 1, 1),
	},
	["InfoBarWarningBackground"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.992157, 0.984314, 0.67451),
	},
	["InfoBarWarningText"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0, 0, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0, 0, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0, 0, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0, 0, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0, 0, 0),
	},
	["ScriptMethod"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.992157, 0.984314, 0.67451),
	},
	["ScriptProperty"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.380392, 0.631373, 0.945098),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.380392, 0.631373, 0.945098),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.380392, 0.631373, 0.945098),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.380392, 0.631373, 0.945098),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.380392, 0.631373, 0.945098),
	},
	["ScriptNil"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.776471, 0),
	},
	["ScriptBool"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(1, 0.776471, 0),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(1, 0.776471, 0),
	},
	["ScriptFunction"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.972549, 0.427451, 0.486275),
	},
	["ScriptLocal"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.972549, 0.427451, 0.486275),
	},
	["ScriptSelf"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.972549, 0.427451, 0.486275),
	},
	["ScriptLuauKeyword"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.972549, 0.427451, 0.486275),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.972549, 0.427451, 0.486275),
	},
	["ScriptFunctionName"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.992157, 0.984314, 0.67451),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.992157, 0.984314, 0.67451),
	},
	["ScriptTodo"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.4, 0.4, 0.4),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.4, 0.4, 0.4),
	},
	["ScriptBracket"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.8, 0.8, 0.8),
	},
	["AttributeCog"] = {
		[Enum.StudioStyleGuideModifier.Default] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Selected] = Color3.new(0.8, 0.8, 0.8),
		[Enum.StudioStyleGuideModifier.Pressed] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Disabled] = Color3.new(0.666667, 0.666667, 0.666667),
		[Enum.StudioStyleGuideModifier.Hover] = Color3.new(0.666667, 0.666667, 0.666667),
	},
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">NexusPluginFrameworkProject</string>
            <string name="Source">--[[
TheNexusAvenger

Project used for managing resources in Nexus Plugin Framework.
--]]

local NexusProject = require(script.Parent:WaitForChild("NexusProject"))
local NexusPluginFrameworkProject = NexusProject.new(script.Parent)



return NexusPluginFrameworkProject</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="18">
          <Properties>
            <string name="Name">Plugin</string>
          </Properties>
          <Item class="ModuleScript" referent="19">
            <Properties>
              <string name="Name">NexusPlugin</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox's Plugin class.
--]]

local CLASS_NAME = "NexusPlugin"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")
local NexusStudioTheme = NexusPluginFramework:GetResource("Plugin.NexusStudioTheme")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")

local NexusPlugin = NexusContainer:Extend()
NexusPlugin:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusPlugin)

local CachedPlugin = plugin



--[[
Returns a static plugin instance. Note it may not be
a "mock" plugin (NexusPlugin).
--]]
function NexusPlugin.GetPlugin()
	--Craete the cached plugin if needed.
	if not CachedPlugin then
		CachedPlugin = NexusPlugin.new()
	end
	
	--Return the cached plugin.
	return CachedPlugin
end

--[[
Sets the static plugin instance. Needed to be
used in a Script since plugin is not defined
in ModuleScripts, even if it required by a plugin
Script.
--]]
function NexusPlugin.SetPlugin(NewPlugin)
	CachedPlugin = NewPlugin
end

--[[
Creates a Nexus Plugin object.
--]]
function NexusPlugin:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	
	self.CollisionEnabled = true
	self.GridSize = 1
	
	self.Deactivation = NexusEventCreator:CreateEvent()
	self.Unloading = NexusEventCreator:CreateEvent()
end

--[[
Sets the state of the calling plugin to activated.
--]]
function NexusPlugin:Activate(ExclusiveMouse)
	warn("Unimplemented: NexusPlugin:Activate(ExclusiveMouse)")
end

--[[
This function creates a DockWidgetPluginGui using the
	provided DockWidgetPluginGuiInfo.
--]]
function NexusPlugin:CreateDockWidgetPluginGui(PluginGuiId,WidgetPluginGuiInfo)
	error("Unimplemented: NexusPlugin:CreateDockWidgetPluginGui(PluginGuiId,WidgetPluginGuiInfo)")
end

--[[
Creates a PluginAction which is an object that represents
a generic performable action in Roblox Studio, with no
directly associated Toolbar or Button.
--]]
function NexusPlugin:CreatePluginAction(ActionId,Text,StatusTip,IconName,AllowBinding)
	error("Unimplemented: NexusPlugin:CreatePluginAction(ActionId,Text,StatusTip,IconName,AllowBinding)")
end

--[[
Creates a new plugin menu.
--]]
function NexusPlugin:CreatePluginMenu(Id,Title,Icon)
	error("Unimplemented: NexusPlugin:CreatePluginMenu(Id,Title,Icon)")
end

--[[
Gets or creates a new Toolbar with the specified name,
which is then used to create a plugin button.
--]]
function NexusPlugin:CreateToolbar(Name)
	error("Unimplemented: NexusPlugin:CreateToolbar(Name)")
end

--[[
Deactivates the plugin.
--]]
function NexusPlugin:Deactivate()
	warn("Unimplemented: NexusPlugin:Deactivate()")
end

--[[
Returns the JointCreationMode the user has set in studio
under the Model tab.
--]]
function NexusPlugin:GetJoinMode()
	warn("Unimplemented: NexusPlugin:GetJoinMode()")
	return Enum.JointCreationMode.Surface
end

--[[
Returns a mouse that can be used with the plugin.
--]]
function NexusPlugin:GetMouse()
	error("Unimplemented: NexusPlugin:GetMouse()")
end

--[[
Returns the currently selected RibbonTool.
--]]
function NexusPlugin:GetSelectedRibbonTool()
	error("Unimplemented: NexusPlugin:GetSelectedRibbonTool()")
end

--[[
Retrieves a previously stored value with the given key,
or nil if the given key doesn’t exist.
--]]
function NexusPlugin:GetSetting(Key)
	error("Unimplemented: NexusPlugin:GetSetting(Key)")
end

--[[
Returns the studio user’s userId if they’re logged in,
otherwise returns 0.
--]]
function NexusPlugin:GetStudioUserId()
	error("Unimplemented: NexusPlugin:GetStudioUserId()")
end

--[[
Prompts the user to open a .fbx animation file that can
be loaded onto the rigModel, then proceeds to insert the
animation as a KeyframeSequence in the Workspace.
--]]
function NexusPlugin:ImportFbxAnimation(RigModel,IsR15)
	error("Unimplemented: NexusPlugin:ImportFbxAnimation(RigModel,IsR15)")
end

--[[
Prompts the user to open a .fbx file, uploads the individual
components of the model as meshes, and generates a character
rig for use in animation, which is loaded into the Workspace.
--]]
function NexusPlugin:ImportFbxRig(IsR15)
	error("Unimplemented: NexusPlugin:ImportFbxRig(IsR15)")
end

--[[
Returns true if this plugin is currently active, after having
been activated via the Plugin:Activate function.
--]]
function NexusPlugin:IsActivated()
	error("Unimplemented: NexusPlugin:IsActivated()")
end

--[[
Returns true if this plugin is currently active with an
exclusive mouse, after having been activated via the
Plugin:Activate function.
--]]
function NexusPlugin:IsActivatedWithExclusiveMouse()
	error("Unimplemented: NexusPlugin:IsActivatedWithExclusiveMouse()")
end

--[[
Negates the given parts and returns the resulting
NegateOperations.
--]]
function NexusPlugin:Negate(Objects)
	error("Unimplemented: NexusPlugin:Negate(Objects)")
end

--[[
Used to open the given script instance in an editor window,
in Roblox studio, at the given line. If no line is given
as an argument it will default to 0.
--]]
function NexusPlugin:OpenScript(Script,LineNumber)
	error("Unimplemented: NexusPlugin:OpenScript(Script,LineNumber)")
end

--[[
Opens the context help window to the wiki page that url
links to.
--]]
function NexusPlugin:OpenWikiPage(URL)
	error("Unimplemented: NexusPlugin:OpenWikiPage(URL)")
end

--[[
Opens a window in Roblox Studio, which prompts the user to
select an asset based on the assetType specified. Returns
what assetId was selected, or -1 if the window was closed.
--]]
function NexusPlugin:PromptForExistingAssetId(AssetType)
	error("Unimplemented: NexusPlugin:PromptForExistingAssetId(AssetType)")
end

--[[
Prompts the user to save their current selection with the
specified file name. Returns true if the user did save the file.
--]]
function NexusPlugin:PromptSaveSelection(SuggestedFileName)
	error("Unimplemented: NexusPlugin:PromptSaveSelection(SuggestedFileName)")
end

--[[
Opens an upload window for the user’s current selection.
--]]
function NexusPlugin:SaveSelectedToRoblox()
	error("Unimplemented: NexusPlugin:SaveSelectedToRoblox()")
end

--[[
Activates the specified Roblox Studio tool.
--]]
function NexusPlugin:SelectRibbonTool(Tool,Position)
	error("Unimplemented: NexusPlugin:SelectRibbonTool(Tool,Position)")
end

--[[
Separates the given UnionOperations and returns the resulting parts.
--]]
function NexusPlugin:Separate(Objects)
	error("Unimplemented: NexusPlugin:Separate(Objects)")
end

--[[
Stores a given value for later use under the given key. The value
will persist even after studio is closed.
--]]
function NexusPlugin:SetSetting(Key,Value)
	error("Unimplemented: NexusPlugin:SetSetting(Key,Value)")
end

--[[
Unions the given parts and returns the resulting UnionOperation.
--]]
function NexusPlugin:Union(Objects)
	error("Unimplemented: NexusPlugin:Union(Objects)")
end



return NexusPlugin</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="20">
            <Properties>
              <string name="Name">NexusPluginButton</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox's PluginButton class.
--]]

local CLASS_NAME = "NexusPluginButton"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")

local NexusPluginButton = NexusWrappedInstance:Extend()
NexusPluginButton:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusPluginButton)



--[[
Creates a Nexus Plugin Button object.
--]]
function NexusPluginButton:__new(Toolbar,ButtonName,ButtonTooltip,ButtonIcon)
	--Correct the inputs.
	if not ButtonName then
		error("Button name can't be nil.")
	end
	ButtonTooltip = ButtonTooltip or ""
	ButtonIcon = ButtonIcon or ""
	
	--Create the button.
	local Button = Toolbar.Toolbar:CreateButton(ButtonName,ButtonTooltip,ButtonIcon)
	self:InitializeSuper(Button)
	self.Name = CLASS_NAME
	
	--Store the button.
	self:__SetChangedOverride("Button",function() end)
	self.Button = Button
	
	--Connect the changes.
	self:__SetChangedOverride("Active",function()
		self.Button:SetActive(self.Active)
	end)
	self.Active = false
end



return NexusPluginButton</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="21">
            <Properties>
              <string name="Name">NexusPluginGui</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox's PluginGui class.
--]]

local CLASS_NAME = "NexusPluginGui"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusPlugin = NexusPluginFramework:GetResource("Plugin.NexusPlugin")
local NexusPluginButton = NexusPluginFramework:GetResource("Plugin.NexusPluginButton")

local NexusPluginGui = NexusWrappedInstance:Extend()
NexusPluginGui:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusPluginGui)



--[[
Creates a Nexus Plugin Gui object.
--]]
function NexusPluginGui:__new(WidgetName,DockWidgetInfo)
	local PluginGui = NexusPlugin.GetPlugin():CreateDockWidgetPluginGui(WidgetName,DockWidgetInfo)
	self:InitializeSuper(PluginGui)
	
	--Store the Gui.
	self:__SetChangedOverride("PluginGui",function() end)
	self.PluginGui = PluginGui
	
	--Set the defaults.
	self.Title = WidgetName
	self.Name = WidgetName
end



return NexusPluginGui</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="22">
            <Properties>
              <string name="Name">NexusPluginToolbar</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox's PluginToolbar class.
--]]

local CLASS_NAME = "NexusPluginToolbar"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusPlugin = NexusPluginFramework:GetResource("Plugin.NexusPlugin")
local NexusPluginButton = NexusPluginFramework:GetResource("Plugin.NexusPluginButton")

local NexusPluginToolbar = NexusWrappedInstance:Extend()
NexusPluginToolbar:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusPluginToolbar)



--[[
Creates a Nexus Plugin Toolbar object.
--]]
function NexusPluginToolbar:__new(ToolbarName)
	local Toolbar = NexusPlugin.GetPlugin():CreateToolbar(ToolbarName)
	self:InitializeSuper(Toolbar)
	self.Name = CLASS_NAME
	
	--Store the toolbar.
	self:__SetChangedOverride("Toolbar",function() end)
	self.Toolbar = Toolbar
end

--[[
Creates a button button.
--]]
function NexusPluginToolbar:CreateButton(ButtonName,ButtonTooltip,ButtonIcon)
	return NexusPluginButton.new(self,ButtonName,ButtonTooltip,ButtonIcon)
end



return NexusPluginToolbar</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="23">
            <Properties>
              <string name="Name">NexusSettings</string>
              <string name="Source">--[[
TheNexusAvenger

Proxy's Roblox's settings.
--]]

local CLASS_NAME = "NexusSettings"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")

local NexusSettings = NexusContainer:Extend()
NexusSettings:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusSettings)

local CachedSettings

--[[
Returns a singleton version of the settings.
--]]
function NexusSettings.GetSettings()
	--Create the cached settings.
	if not CachedSettings then
		CachedSettings = NexusSettings.new()
	end
	
	--Return the cached settings.
	return CachedSettings
end

--[[
Creates a Nexus Settings object.
--]]
function NexusSettings:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
end

--[[
Returns the setting for the given category and name.
--]]
function NexusSettings:GetSetting(Category,Name)
	return settings()[Category][Name]
end

--[[
Sets the setting for the given category and name.
--]]
function NexusSettings:SetSetting(Category,Name,Value)
	settings()[Category][Name] = Value
end

--[[
Returns a changed signal for a given property. If the name
is nil, a changed signal for the category is returned.
--]]
function NexusSettings:GetSettingsChangedSignal(Category,Name)
	--Get the settings category.
	local SettingsCategory = settings()[Category]
	
	--Return the changed signal.
	if Name == nil then
		return SettingsCategory.Changed
	else
		return SettingsCategory:GetPropertyChangedSignal(Name)
	end
end



return NexusSettings</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="24">
            <Properties>
              <string name="Name">NexusStudioTheme</string>
              <string name="Source">--[[
TheNexusAvenger

Mirrors the API of Roblox's StudioTheme class.
--]]

local CLASS_NAME = "NexusStudioTheme"



local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")
local ThemeColors = NexusPluginFramework:GetResource("Data.ThemeColors")

local NexusStudioTheme = NexusContainer:Extend()
NexusStudioTheme:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusStudioTheme)

local CachedTheme



--[[
Creates a theme class from an enum.
--]]
function NexusStudioTheme.FromThemeEnum()
	--Create the cached theme.
	if not CachedTheme then
		CachedTheme = NexusStudioTheme.new()
	end
	
	--Return the cached theme.
	return CachedTheme
end

--[[
Creates a Studio Theme object.
--]]
function NexusStudioTheme:__new()
	self:InitializeSuper()
	
	--Store the theme and set the name.
	self.Name = "Fallback"
end

--[[
Returns the color corresponding to the arguments provided.
--]]
function NexusStudioTheme:GetColor(StyleGuideColor,Modifier)
	--Correct the input.
	if typeof(StyleGuideColor) == "EnumItem" then
		StyleGuideColor = string.sub(tostring(StyleGuideColor),28)
	end
	
	if not Modifier then
		Modifier = Enum.StudioStyleGuideModifier.Default
	elseif type(Modifier) == "string" then
		Modifier = Enum.StudioStyleGuideModifier[Modifier]
	end
	
	--Return the color.
	return ThemeColors[StyleGuideColor][Modifier]
end

--[[
Returns the path of an asset (or image) for the Id and Modifier.
--]]
function NexusStudioTheme:GetPath(AssetId,Modifier)
	warn("Unimplemented: NexusStudioTheme:GetPath(AssetId,Modifier)")
	return "Unimplemented"
end



return NexusStudioTheme</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="25">
            <Properties>
              <string name="Name">NexusUserInput</string>
              <string name="Source">--[[
TheNexusAvenger

Static class for user input. Recommended to only use it
for key presses since the key presses are from all PluginGuis
and main viewport.
--]]

local CLASS_NAME = "NexusUserInput"

local INPUT_DELAY_TIME = 0.05



local UserInputService = game:GetService("UserInputService")
local PluginGuiService = game:GetService("PluginGuiService")

local NexusPluginFramework = require(script.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")

local NexusUserInput = NexusContainer:Extend()
NexusUserInput:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusUserInput)



--Create the events.
NexusUserInput.LastInputBeganTimes = {}
NexusUserInput.LastInputChangedTimes = {}
NexusUserInput.LastInputEndedTimes = {}
NexusUserInput.InputBegan = NexusEventCreator:CreateEvent()
NexusUserInput.InputChanged = NexusEventCreator:CreateEvent()
NexusUserInput.InputEnded = NexusEventCreator:CreateEvent()



--[[
Creates a User Input object.
--]]
function NexusUserInput:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	
	--Set up the context events.
	self.__ContextEvents = {}
	
	--Create the time checkers.
	self.LastInputBeganTimes = {}
	self.LastInputChangedTimes = {}
	self.LastInputEndedTimes = {}

	--Create the events.
	self.InputBegan = NexusEventCreator:CreateEvent()
	self.InputChanged = NexusEventCreator:CreateEvent()
	self.InputEnded = NexusEventCreator:CreateEvent()
end

--[[
Invoked when an input is began.
--]]
function NexusUserInput:OnInputBegan(InputObject,Processed)
	--Return if it was processed.
	if Processed then return end
	
	--Fire the event if it new.
	local LastTime = self.LastInputBeganTimes[InputObject] or 0
	local CurrentTime = tick()
	if CurrentTime - LastTime >= INPUT_DELAY_TIME then
		self.InputBegan:Fire(InputObject)
	end
	
	--Store the last time.
	self.LastInputBeganTimes[InputObject] = CurrentTime
end

--[[
Invoked when an input is changed.
--]]
function NexusUserInput:OnInputChanged(InputObject,Processed)
	--Return if it was processed.
	if Processed then return end
	
	--Fire the event if it new.
	local LastTime = self.LastInputChangedTimes[InputObject] or 0
	local CurrentTime = tick()
	if CurrentTime - LastTime >= INPUT_DELAY_TIME then
		self.InputChanged:Fire(InputObject)
	end
	
	--Store the last time.
	self.LastInputChangedTimes[InputObject] = CurrentTime
end

--[[
Invoked when an input is ended.
--]]
function NexusUserInput:OnInputEnded(InputObject,Processed)
	--Return if it was processed.
	if Processed then return end
	
	--Fire the event if it new.
	local LastTime = self.LastInputEndedTimes[InputObject] or 0
	local CurrentTime = tick()
	if CurrentTime - LastTime >= INPUT_DELAY_TIME then
		self.InputEnded:Fire(InputObject)
	end
	
	--Store the last time.
	self.LastInputEndedTimes[InputObject] = CurrentTime
end

--[[
Adds a context for getting inputs.
--]]
function NexusUserInput:AddContext(Frame)
	--Connect the events.
	local Events = {}
	table.insert(Events,Frame:ConnectToHighestParent("InputBegan",function(InputObject,Processed)
		self:OnInputBegan(InputObject,Processed)
	end))
	table.insert(Events,Frame:ConnectToHighestParent("InputChanged",function(InputObject,Processed)
		self:OnInputChanged(InputObject,Processed)
	end))
	table.insert(Events,Frame:ConnectToHighestParent("InputEnded",function(InputObject,Processed)
		self:OnInputEnded(InputObject,Processed)
	end))
	
	--Store the events.
	self.__ContextEvents[Frame] = Events
end

--[[
Removes a context for getting inputs.
--]]
function NexusUserInput:RemoveContext(Frame)
	--Disconnect the events.
	local Events = self.__ContextEvents[Frame]
	if Events then
		self.__ContextEvents[Frame] = nil
		for _,Event in pairs(Events) do
			Event:Disconnect()
		end
	end
end



--Connect the PluginGuis input events.
PluginGuiService.DescendantAdded:Connect(function(Frame)
	if Frame:IsA("GuiObject") then
		Frame.InputBegan:Connect(function(InputObject,Processed)
			NexusUserInput:OnInputBegan(InputObject,Processed)
		end)
		Frame.InputChanged:Connect(function(InputObject,Processed)
			NexusUserInput:OnInputChanged(InputObject,Processed)
		end)
		Frame.InputEnded:Connect(function(InputObject,Processed)
			NexusUserInput:OnInputEnded(InputObject,Processed)
		end)
	end
end)

--Connect the UserInputService.
UserInputService.InputBegan:Connect(function(InputObject,Processed)
	NexusUserInput:OnInputBegan(InputObject,Processed)
end)
UserInputService.InputChanged:Connect(function(InputObject,Processed)
	NexusUserInput:OnInputChanged(InputObject,Processed)
end)
UserInputService.InputEnded:Connect(function(InputObject,Processed)
	NexusUserInput:OnInputEnded(InputObject,Processed)
end)



return NexusUserInput</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="26">
          <Properties>
            <string name="Name">UI</string>
          </Properties>
          <Item class="Folder" referent="27">
            <Properties>
              <string name="Name">CollapsableList</string>
            </Properties>
            <Item class="Folder" referent="28">
              <Properties>
                <string name="Name">Constraint</string>
              </Properties>
              <Item class="ModuleScript" referent="29">
                <Properties>
                  <string name="Name">NexusCollapsableListFrameConstraint</string>
                  <string name="Source">--[[
TheNexusAvenger

Abstract class for a constraint on list frames.
--]]

local CLASS_NAME = "NexusCollapsableListFrameConstraint"



local NexusPluginFramework = require(script.Parent.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")

local NexusCollapsableListFrameConstraint = NexusContainer:Extend()
NexusCollapsableListFrameConstraint:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusCollapsableListFrameConstraint)



--[[
Creates a Nexus Collapsable List Frame Constraint object.
--]]
function NexusCollapsableListFrameConstraint:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	self.__ListFrames = {}
	
	--Create the events.
	self.ListFrameAdded = NexusEventCreator:CreateEvent()
	self.ListFrameRemoved = NexusEventCreator:CreateEvent()
	self.ListFramesUpdated = NexusEventCreator:CreateEvent()
end

--[[
Returns if the constraint contains the list frame.
--]]
function NexusCollapsableListFrameConstraint:ContainsListFrame(ListFrame)
	--Return true if the list frame exists.
	for Key,Value in pairs(self.__ListFrames) do
		if Value == ListFrame then
			return true
		end
	end
	
	--Return false (not contained).
	return false
end

--[[
Returns the list frames part of the constraint.
--]]
function NexusCollapsableListFrameConstraint:GetListFrames()
	--Clone the table.
	local ListFrames = {}
	for Key,Value in pairs(self.__ListFrames) do
		ListFrames[Key] = Value
	end
	
	--Return the table.
	return ListFrames
end

--[[
Returns all of the list frames in the constraint.
--]]
function NexusCollapsableListFrameConstraint:GetAllListFrames(OnlyShowVisible)
	local ListFrames = {}
	
	--[[
	Adds a child frame.
	--]]
	local function AddFrame(Frame)
		--Return if it isn't a frame.
		if not Frame:IsA("NexusCollapsableListFrame") then
			return
		end
		
		--Add the frame.
		if Frame.Visible then
			table.insert(ListFrames,Frame)
			
			--Add the children if it is expanded or all are added.
			if OnlyShowVisible ~= true or Frame.Expanded then
				for _,SubFrame in pairs(Frame:GetCollapsableContainer():GetChildren()) do
					AddFrame(SubFrame)
				end
			end
		end
	end
	
	--Add the frames.
	for _,Frame in pairs(self.__ListFrames) do
		AddFrame(Frame)
	end
	
	--Return the table.
	return ListFrames
end

--[[
Sorts the list frames using a given function.
--]]
function NexusCollapsableListFrameConstraint:SortListFrames(SortFunction)
	--Sort the list frames.
	table.sort(self.__ListFrames,SortFunction)
	
	--Fire the updated event.
	self.ListFramesUpdated:Fire()
end
--[[
Adds a list frame to the constraint.
--]]
function NexusCollapsableListFrameConstraint:AddListFrame(ListFrame,Index)
	--Return if the list frame is in the constraint.
	if self:ContainsListFrame(ListFrame) then
		return
	end
	
	--Insert the list frame.
	if Index then
		table.insert(self.__ListFrames,Index,ListFrame)
	else
		table.insert(self.__ListFrames,ListFrame)
	end
	
	--Fire the updated events.
	self.ListFrameAdded:Fire(ListFrame)
	self.ListFramesUpdated:Fire()
end

--[[
Removes a list frame to the constraint.
--]]
function NexusCollapsableListFrameConstraint:RemoveListFrame(ListFrame)
	--Get the index.
	local Index
	for Key,Value in pairs(self.__ListFrames) do
		if Value == ListFrame then
			Index = Key
			break
		end
	end
	
	--Remove the index if it exists and fire the events.
	if Index then
		table.remove(self.__ListFrames,Index)
		self.ListFrameRemoved:Fire(ListFrame)
		self.ListFramesUpdated:Fire()
	end
end

--[[
Removes all of the list frames to the constraint.
--]]
function NexusCollapsableListFrameConstraint:ClearListFrames()
	local ListFrames = self:GetListFrames()
	
	--Clear the list frames.
	self.__ListFrames = {}
	for _,ListFrame in pairs(ListFrames) do
		self.ListFrameRemoved:Fire(ListFrame)
	end
	
	--Fire the updated event.
	self.ListFramesUpdated:Fire()
end



return NexusCollapsableListFrameConstraint</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="30">
                <Properties>
                  <string name="Name">NexusContentsPropertyConstraint</string>
                  <string name="Source">--[[
TheNexusAvenger

Constraint that passes through certain properties (Disabled
and Selected) to the frames parented to the main contents frame
of list frames.
--]]

local CLASS_NAME = "NexusContentsPropertyConstraint"



local NexusPluginFramework = require(script.Parent.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")
local NexusCollapsableListFrameConstraint = NexusPluginFramework:GetResource("UI.CollapsableList.Constraint.NexusCollapsableListFrameConstraint")

local NexusContentsPropertyConstraint = NexusCollapsableListFrameConstraint:Extend()
NexusContentsPropertyConstraint:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusContentsPropertyConstraint)



--[[
Creates a Nexus Collapsable List Frame Contents Property Constraint object.
--]]
function NexusContentsPropertyConstraint:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	
	local GlobalListFrameConnections = {}
	
	--[[
	Updates the properties of the contents of the contents of a list frame.
	--]]
	local function UpdateListFrameContainerPrperties(ListFrame)
		local Selected,Disabled = ListFrame.Selected,ListFrame.Disabled
		for _,Frame in pairs(ListFrame:GetMainContainer():GetDescendants()) do
			if Frame:IsA("NexusWrappedInstance") then
				Frame.Selected = Selected
				Frame.Disabled = Disabled
			end
		end
	end
	
	--[[
	Handles a list frame being added.
	--]]
	local function ListFrameAdded(ListFrame)
		local ListFrameConnections = {}
		
		--Connect the events.
		local Events = {}
		table.insert(Events,ListFrame:GetCollapsableContainer().DescendantAdded:Connect(function(ListFrame)
			if ListFrame:IsA("NexusCollapsableListFrame") then
				--Connect the events.
				local Events = {}
				table.insert(Events,ListFrame:GetMainContainer().ChildAdded:Connect(function()
					UpdateListFrameContainerPrperties(ListFrame)
				end))
				table.insert(Events,ListFrame:GetPropertyChangedSignal("Disabled"):Connect(function()
					UpdateListFrameContainerPrperties(ListFrame)
				end))
				table.insert(Events,ListFrame:GetPropertyChangedSignal("Selected"):Connect(function()
					UpdateListFrameContainerPrperties(ListFrame)
				end))
				
				--Store the events.
				ListFrameConnections[ListFrame] = Events
				
				--Update the list frame properties.
				UpdateListFrameContainerPrperties(ListFrame)
			end
		end))
		table.insert(Events,ListFrame:GetCollapsableContainer().DescendantRemoving:Connect(function(ListFrame)
			local Events = ListFrameConnections[ListFrame]
			if Events then
				ListFrameConnections[ListFrame] = nil
				for _,Event in pairs(Events) do
					Event:Disconnect()
				end
			end
		end))
		table.insert(Events,ListFrame:GetMainContainer().ChildAdded:Connect(function()
			UpdateListFrameContainerPrperties(ListFrame)
		end))
		table.insert(Events,ListFrame:GetPropertyChangedSignal("Disabled"):Connect(function()
			UpdateListFrameContainerPrperties(ListFrame)
		end))
		table.insert(Events,ListFrame:GetPropertyChangedSignal("Selected"):Connect(function()
			UpdateListFrameContainerPrperties(ListFrame)
		end))
		
		--Store the events.
		GlobalListFrameConnections[ListFrame] = Events
		
		--Update the list frame properties.
		UpdateListFrameContainerPrperties(ListFrame)
	end
	
	--[[
	Handles a list frame being removed.
	--]]
	local function ListFrameRemoved(ListFrame)
		local Events = GlobalListFrameConnections[ListFrame]
		if Events then
			GlobalListFrameConnections[ListFrame] = nil
			for _,Event in pairs(Events) do
				Event:Disconnect()
			end
		end
	end
	
	--Connect the events.
	self.ListFrameAdded:Connect(ListFrameAdded)
	self.ListFrameRemoved:Connect(ListFrameRemoved)
end



return NexusContentsPropertyConstraint</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="31">
                <Properties>
                  <string name="Name">NexusMultiConstraint</string>
                  <string name="Source">--[[
TheNexusAvenger

Helper class that applies multiple constraints as one
constraint.
--]]

local CLASS_NAME = "NexusMultiConstraint"



local NexusPluginFramework = require(script.Parent.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusCollapsableListFrameConstraint = NexusPluginFramework:GetResource("UI.CollapsableList.Constraint.NexusCollapsableListFrameConstraint")

local NexusMultiConstraint = NexusCollapsableListFrameConstraint:Extend()
NexusMultiConstraint:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusMultiConstraint)



--[[
Creates a Nexus Collapsable List Frame Multi Constraint object.
--]]
function NexusMultiConstraint:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	self.__Constraints = {}
end

--[[
Adds a constraint.
--]]
function NexusMultiConstraint:AddConstraint(Constraint)
	--Add the constraint.
	table.insert(self.__Constraints,Constraint)
	
	--Add the existing frames.
	for i,Frame in pairs(self:GetListFrames()) do
		Constraint:AddListFrame(Frame,i)
	end
end

--[[
Adds a list frame to the constraint.
--]]
function NexusMultiConstraint:AddListFrame(ListFrame,Index)
	self.super:AddListFrame(ListFrame,Index)
	
	--Add the frame to the constraints.
	for _,Constraint in pairs(self.__Constraints) do
		Constraint:AddListFrame(ListFrame,Index)
	end
end

--[[
Removes a list frame to the constraint.
--]]
function NexusMultiConstraint:RemoveListFrame(ListFrame)
	self.super:RemoveListFrame(ListFrame)
	
	--Remove the frame from the constraints.
	for _,Constraint in pairs(self.__Constraints) do
		Constraint:RemoveListFrame(ListFrame)
	end
end

--[[
Removes all of the list frames to the constraint.
--]]
function NexusMultiConstraint:ClearListFrames()
	self.super:ClearListFrames()
	
	--Clear the frames from the constraints.
	for _,Constraint in pairs(self.__Constraints) do
		Constraint:ClearListFrames()
	end
end



return NexusMultiConstraint</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="32">
                <Properties>
                  <string name="Name">NexusSelectionConstraint</string>
                  <string name="Source">--[[
TheNexusAvenger

Constraint that ensures only one list frame or certain
list frames based on the keys pressed are selected. Also
adds support for arrow keys.

TODO: The method for Shift isn't exactly correct compared
to the normal implementation.
--]]

local CLASS_NAME = "NexusSelectionConstraint"

local MIN_WAIT_TIME_FOR_ARROWS = 0.5
local INCREMENT_WAIT_TIME = 0.03



local NexusPluginFramework = require(script.Parent.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusUserInput = NexusPluginFramework:GetResource("Plugin.NexusUserInput")
local NexusCollapsableListFrameConstraint = NexusPluginFramework:GetResource("UI.CollapsableList.Constraint.NexusCollapsableListFrameConstraint")

local NexusSelectionConstraint = NexusCollapsableListFrameConstraint:Extend()
NexusSelectionConstraint:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusSelectionConstraint)



--[[
Creates a Nexus Collapsable List Frame Selection Constraint object.
--]]
function NexusSelectionConstraint:__new()
	self:InitializeSuper()
	self.Name = CLASS_NAME
	
	--Set up checking for Control and Shift being pressed.
	local ControlPressed,ShiftPressed = false,false
	local KeyboardContext = NexusUserInput.new()
	local PressedEvents = {}
	
	--[[
	Sets up the inputs for a list frame.
	--]]
	local function ConnectPressedEvents(ListFrame)
		KeyboardContext:AddContext(ListFrame)
	end
	
	--[[
	Disconnects the events for a list frame.
	--]]
	local function DisconnectPressedEvents(ListFrame)
		KeyboardContext:RemoveContext(ListFrame)
	end
	self.ListFrameAdded:Connect(ConnectPressedEvents)
	self.ListFrameRemoved:Connect(DisconnectPressedEvents)
	
	--Connect the events for Control and Shift.
	NexusUserInput.InputBegan:Connect(function(Input)
		if Input.KeyCode == Enum.KeyCode.LeftControl or Input.KeyCode == Enum.KeyCode.RightControl then
			ControlPressed = true
		elseif Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.RightShift then
			ShiftPressed = true
		end
	end)
	
	NexusUserInput.InputEnded:Connect(function(Input)
		if Input.KeyCode == Enum.KeyCode.LeftControl or Input.KeyCode == Enum.KeyCode.RightControl then
			ControlPressed = false
		elseif Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.RightShift then
			ShiftPressed = false
		end
	end)
	
	--Connect the selection events.
	local UpPressStart,DownPressStart
	local SelectionOrder = {}
	local SelectionEvents = {}
	
	--[[
	Increments the selection.
	--]]
	local function IncrementSelection(IndexIncrement)
		--Get the base increment.
		local CurrentIndex
		local ListFrames = self:GetAllListFrames(true)
		local LastSelection = SelectionOrder[#SelectionOrder]
		if not LastSelection then
			LastSelection = ListFrames[1]
		end
		
		--Get the index of the first and new selection.
		for Index,Frame in pairs(ListFrames) do
			if Frame == LastSelection then
				CurrentIndex = Index
				break
			end
		end
		
		--Increment the selection.
		if CurrentIndex then
			local NextSelection = ListFrames[CurrentIndex + IndexIncrement]
			if NextSelection then
				if NextSelection.Selected then
					LastSelection.Selected = false
				else
					NextSelection.Selected = true
				end
			end
		end
	end
	
	--[[
	Updates the quick-increment direction.
	--]]
	local function UpdateIncrement()
		local Direction = 0
		
		--Determine the direction.
		if UpPressStart and tick() - UpPressStart > MIN_WAIT_TIME_FOR_ARROWS then
			Direction = Direction - 1
		end
		if DownPressStart and tick() - DownPressStart > MIN_WAIT_TIME_FOR_ARROWS then
			Direction = Direction + 1
		end
		
		--If the direction isn't 0, move the selection.
		if Direction ~= 0 then
			IncrementSelection(Direction)
		end
	end
	
	--Connect the events for up and down.
	KeyboardContext.InputBegan:Connect(function(Input)
		if Input.KeyCode == Enum.KeyCode.Up then
			--Move the selection up.
			local StartTime = tick()
			UpPressStart = StartTime
			IncrementSelection(-1)
			wait(MIN_WAIT_TIME_FOR_ARROWS)
			
			--Start the loop for the up key.
			while UpPressStart == StartTime do
				UpdateIncrement()
				wait(INCREMENT_WAIT_TIME)
			end
		elseif Input.KeyCode == Enum.KeyCode.Down then
			--Move the selection down.
			local StartTime = tick()
			DownPressStart = StartTime
			IncrementSelection(1)
			wait(MIN_WAIT_TIME_FOR_ARROWS)
			
			--Start the loop for the down key.
			while DownPressStart == StartTime do
				UpdateIncrement()
				wait(INCREMENT_WAIT_TIME)
			end
		end
	end)
	
	KeyboardContext.InputEnded:Connect(function(Input)
		if Input.KeyCode == Enum.KeyCode.Up then
			UpPressStart = nil
		elseif Input.KeyCode == Enum.KeyCode.Down then
			DownPressStart = nil
		end
	end)
	
	--[[
	Connects the events for a list frame.
	--]]
	local function ConnectSelectionChanged(ListFrame)
		local Events = {}
		
		--Unselect the frame.
		if ListFrame.Selected then
			if not self.AllowMultipleSelections and #SelectionOrder >= 1 then
				ListFrame.Selected = false
			else
				table.insert(SelectionOrder,ListFrame)
			end
		end
		
		--Connect the selection changed events.
		table.insert(Events,ListFrame:GetPropertyChangedSignal("Selected"):Connect(function()
			local Selected = ListFrame.Selected
			if Selected then
				--Set the selection.
				if self.AllowMultipleSelections and (ControlPressed or ShiftPressed) then
					--Add the selection.
					table.insert(SelectionOrder,ListFrame)
					
					--Select the range.
					if ShiftPressed and SelectionOrder[1] ~= ListFrame then
						local ListFrames = self:GetAllListFrames(true)
						local FirstSelection = SelectionOrder[1]
						
						--Get the index of the first and new selection.
						local FirstIndex,CurrentIndex
						for Index,Frame in pairs(ListFrames) do
							if Frame == FirstSelection then
								FirstIndex = Index
							elseif Frame == ListFrame then
								CurrentIndex = Index
							end
							
							if FirstIndex and CurrentIndex then
								break
							end
						end
						
						--Return if an index is missing.
						if not FirstIndex or not CurrentIndex or FirstIndex == CurrentIndex then
							return
						end
						
						--Swap the indexes if the current is less than the first.
						if FirstIndex > CurrentIndex then
							FirstIndex,CurrentIndex = CurrentIndex,FirstIndex
						end
						
						--Select the frames.
						for i = FirstIndex + 1,CurrentIndex - 1 do
							ListFrames[i].Selected = true
						end
					end
				else
					--Deselect the frames.
					local OldSelectionOrder = SelectionOrder
					SelectionOrder = {}
					for _,Frame in pairs(OldSelectionOrder) do
						if Frame ~= ListFrame then
							Frame.Selected = false
						end
					end
					
					--Select the frame.
					SelectionOrder = {ListFrame}
				end
			else
				--Remove the index.
				local IndexToRemove
				for i,Frame in pairs(SelectionOrder) do
					if Frame == ListFrame then
						IndexToRemove = i
						break
					end
				end
				
				if IndexToRemove then
					table.remove(SelectionOrder,IndexToRemove)
				end
			end
		end))
		
		--Store the events.
		SelectionEvents[ListFrame] = Events
	end
	
	--[[
	Connects the events for a list frame being added.
	--]]
	local function ConnectSelectionAdded(ListFrame)
		--Connect the events.
		ConnectSelectionChanged(ListFrame)
		
		--Connect the descendants.
		for _,Frame in pairs(ListFrame:GetCollapsableContainer():GetDescendants()) do
			ConnectSelectionChanged(Frame)
		end
		
		--Connect the descendant added and removed events.
		local Events = SelectionEvents[ListFrame]
		table.insert(Events,ListFrame:GetCollapsableContainer().DescendantAdded:Connect(function(Descendant)
			ConnectSelectionChanged(Descendant)
		end))
		
		table.insert(Events,ListFrame.DescendantRemoving:Connect(function(Descendant)
			local Events = SelectionEvents[Descendant]
			if Events then
				for _,Event in pairs(Events) do
					Event:Disconnect()
				end
				SelectionEvents[Descendant] = nil
			end
		end))
	end
	
	--[[
	Connects the events for a list frame being removed.
	--]]
	local function ConnectSelectionRemoved(ListFrame)
		--Disconnect the events.
		local Events = SelectionEvents[ListFrame]
		if Events then
			for _,Event in pairs(Events) do
				Event:Disconnect()
			end
			SelectionEvents[ListFrame] = nil
		end
		
		--Disconnect the events of the descendants.
		for _,Frame in pairs(ListFrame:GetDescendants()) do
			if Frame:IsA("NexusCollapsableListFrame") then
				local Events = SelectionEvents[Frame]
				if Events then
					for _,Event in pairs(Events) do
						Event:Disconnect()
					end
					SelectionEvents[Frame] = nil
				end
			end
		end
	end
	self.ListFrameAdded:Connect(ConnectSelectionAdded)
	self.ListFrameRemoved:Connect(ConnectSelectionRemoved)
	
	--Connect the property changes.
	self:GetPropertyChangedSignal("AllowMultipleSelections"):Connect(function()
		--If allowing multiple selections was disabled, disable all but the first selection.
		if not self.AllowMultipleSelections then
			--Deselect the frames.
			local OldSelectionOrder = SelectionOrder
			SelectionOrder = {SelectionOrder[1]}
			for i,Frame in pairs(OldSelectionOrder) do
				if i ~= 1 then
					Frame.Selected = false
				end
			end
		end
	end)
	
	--Set the default properties.
	self.AllowMultipleSelections = false
end



return NexusSelectionConstraint</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="33">
              <Properties>
                <string name="Name">NexusCollapsableListFrame</string>
                <string name="Source">--[[
TheNexusAvenger

Frame that can be expanded or collapsed to show additional information.
Intended to contain additional list frames.
--]]

local CLASS_NAME = "NexusCollapsableListFrame"

local DOUBLE_CLICK_MAX_TIME = 0.5
local EXPANDED_ARROW_IMAGE = "rbxasset://textures/StudioToolbox/ArrowDownIconWhite.png"
local COLLAPSED_ARROW_IMAGE = "rbxasset://textures/ui/LuaApp/icons/ic-arrow-right.png"
local ARROW_RELATIVE_SIZE = (10/20) * (54/38)



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")
local NexusSettings = NexusPluginFramework:GetResource("Plugin.NexusSettings")
local NexusBoundingSizeConstraint = NexusPluginFramework:GetResource("UI.Constraint.NexusBoundingSizeConstraint")

local Settings = NexusSettings.GetSettings()

local NexusCollapsableListFrame = NexusWrappedInstance:Extend()
NexusCollapsableListFrame:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusCollapsableListFrame)



--[[
Creates a Nexus Collapsable List Frame object.
--]]
function NexusCollapsableListFrame:__new()
	self:InitializeSuper("Frame")
	self.Name = CLASS_NAME
	
	--Create the subframes.
	local Arrow = NexusWrappedInstance.GetInstance("ImageButton")
	Arrow.Hidden = true
	Arrow.Name = "Arrow"
	Arrow.BackgroundTransparency = 1
	Arrow.SizeConstraint = "RelativeYY"
	Arrow.Size = UDim2.new(0.9,0,0.9,0)
	Arrow.ImageColor3 = Color3.new(151/255,151/255,151/255)
	Arrow.Parent = self
	self.__Arrow = Arrow
	
	local Container = NexusWrappedInstance.GetInstance("Frame")
	Container.Hidden = true
	Container.BackgroundTransparency = 1
	Container.Name = "Container"
	Container.Size = UDim2.new(1,-16,1,0)
	Container.Position = UDim2.new(1,0,0,0)
	Container.AnchorPoint = Vector2.new(1,0)
	Container.Parent = self
	self.__Container = Container
	
	local CollapsableContainer = NexusWrappedInstance.GetInstance("Frame")
	CollapsableContainer.Hidden = true
	CollapsableContainer.BackgroundTransparency = 1
	CollapsableContainer.Name = "CollapsableContainer"
	CollapsableContainer.Position = UDim2.new(1,0,1,0)
	CollapsableContainer.Size = UDim2.new(1,-16,0,0)
	CollapsableContainer.AnchorPoint = Vector2.new(1,0)
	CollapsableContainer.Parent = self
	self.__CollapsableContainer = CollapsableContainer
	
	--Create the events.
	self:__SetChangedOverride("DoubleClicked",function() end)
	self.DoubleClicked = NexusEventCreator:CreateEvent()
	self:__SetChangedOverride("DelayClicked",function() end)
	self.DelayClicked = NexusEventCreator:CreateEvent()
	
	--Create the constraint.
	local BoundingSizeConstraint = NexusBoundingSizeConstraint.new(CollapsableContainer)
	BoundingSizeConstraint.SizeXOverride = UDim.new(1,-Container.AbsoluteSize.Y)
	self:__SetChangedOverride("__BoundingSizeConstraint",function() end)
	self.__BoundingSizeConstraint = BoundingSizeConstraint
	
	--[[
	Updates the size of everything.
	--]]
	local LastSize,LastCollapsableContainerSize
	local function UpdateSize()
		local DesiredSize = self.Size
		local CollapsableContainerSize = self.Size
		local SizeX,SizeY = DesiredSize.X,DesiredSize.Y
		
		--Return if the size is the same.
		if LastSize == DesiredSize and LastCollapsableContainerSize == CollapsableContainerSize then
			--return
		end
		LastSize = DesiredSize
		
		--Calculate the absolute size Y.
		local Parent = self.Parent
		local AbsoluteDesiredSizeY = (Parent and Parent.AbsoluteSize.Y or 0) * SizeY.Scale + SizeY.Offset
		local ArrowSize = AbsoluteDesiredSizeY * ARROW_RELATIVE_SIZE
		
		--Set the sizes and positions.
		Arrow.Position = UDim2.new(0,(AbsoluteDesiredSizeY - ArrowSize)/2,0,(AbsoluteDesiredSizeY - ArrowSize)/2)
		Arrow.Size = UDim2.new(0,ArrowSize,0,ArrowSize)
		Container.Size = UDim2.new(1,-AbsoluteDesiredSizeY,0,AbsoluteDesiredSizeY)
		BoundingSizeConstraint.SizeXOverride = UDim.new(1,-AbsoluteDesiredSizeY)
		CollapsableContainer.Position = UDim2.new(1,0,0,AbsoluteDesiredSizeY)
		if self.Expanded then
			self:GetWrappedInstance().Size = UDim2.new(SizeX,UDim.new(SizeY.Scale,SizeY.Offset + CollapsableContainer.Size.Y.Offset))
		else
			self:GetWrappedInstance().Size = DesiredSize
		end
	end
	
	--Set up the size changing.
	self.__NoBackwardsReplicationProperties["Size"] = true
	self:__SetChangedOverride("Size",UpdateSize)
	CollapsableContainer:GetPropertyChangedSignal("Size"):Connect(UpdateSize)
	
	--[[
	Returns if a visible frame exists.
	--]]
	local function HasVisibleFrame(Frame)
		--Return true if a frame exists.
		for _,SubFrame in pairs(Frame:GetChildren()) do
			if SubFrame:IsA("Frame") then
				if SubFrame.Visible then --or HasVisibleFrame(SubFrame) then
					return true
				end
			end
		end
		
		--Return false (no frame found).
		return false
	end
	
	--[[
	Updates the visibility of the arrow.
	--]]
	local function UpdateArrowVisibility()
		local ArrowVisible = (self.ArrowVisible == true)
		local HasChildren = HasVisibleFrame(CollapsableContainer)
		
		--Update the visibility.
		Arrow.Visible = ArrowVisible and HasChildren
	end
	
	--[[
	Updates the colors and transparency depending
	on if it is selected or hovered.
	--]]
	local Hovering = false
	local function UpdateContainerColor()
		local Disabled = self.Disabled
		local Selectable = self.Selectable
		local Selected = self.Selected
		
		--Hide the frame if it is not selected or hovering.
		if not Selectable or Disabled or (not Selected and not Hovering) then
			Container.BackgroundTransparency = 1
			return
		end
		
		--Determine the modifier.
		local Modifier = "Hover"
		if Selected then
			Modifier = "Selected"
		end
	
		--Update the color.
		local HighlightColor = self.HighlightColor3
		Container.BackgroundTransparency = 0
		if typeof(HighlightColor) == "Color3" then
			Container.BackgroundColor3 = HighlightColor
		else
			local Theme = Settings:GetSetting("Studio","Theme")
			Container.BackgroundColor3 = Theme:GetColor(HighlightColor,Modifier)
		end
	end
	
	--Connect change events.
	local VisibleChangedEvents = {}
	self:__SetChangedOverride("ArrowVisible",UpdateArrowVisibility)
	CollapsableContainer.ChildAdded:Connect(function(Ins)
		--Connect the visibility changes.
		if Ins:IsA("Frame") then
			VisibleChangedEvents[Ins] = Ins:GetPropertyChangedSignal("Visible"):Connect(UpdateArrowVisibility)
		end
		
		--Update the arrow visiblity.
		UpdateArrowVisibility()
	end)
	CollapsableContainer.ChildRemoved:Connect(function(Ins)
		--Disconnect the visibility changes.
		if VisibleChangedEvents[Ins] then
			VisibleChangedEvents[Ins]:Disconnect()
			VisibleChangedEvents[Ins] = nil
			UpdateArrowVisibility()
		end
	end)
	self:__SetChangedOverride("Disabled",function()
		local Disabled = self.Disabled
		Arrow.Disabled = Disabled
		
		--Update the arrow color.
		if not Disabled then
			Arrow.ImageColor3 = Color3.new(151/255,151/255,151/255)
		else
			Arrow.ImageColor3 = Color3.new(0.3,0.3,0.3)
		end
		
		--Update the container color.
		UpdateContainerColor()
	end)
	Settings:GetSettingsChangedSignal("Studio","Theme"):Connect(UpdateContainerColor)
	self:__SetChangedOverride("HighlightColor3",UpdateContainerColor)
	self:__SetChangedOverride("Selectable",UpdateContainerColor)
	self:__SetChangedOverride("Selected",UpdateContainerColor)
	self:__SetChangedOverride("Expanded",function()
		--Update the arrow texture.
		local Expanded = self.Expanded
		if Expanded then
			Arrow.Image = EXPANDED_ARROW_IMAGE
		else
			Arrow.Image = COLLAPSED_ARROW_IMAGE
		end
		
		--Update the container visibility.
		CollapsableContainer.Visible = Expanded
		
		--Update the size.
		UpdateSize()
	end)
	
	--Set up hovering.
	Container.MouseEnter:Connect(function()
		Hovering = true
		UpdateContainerColor()
	end)
	Container.MouseLeave:Connect(function()
		Hovering = false
		UpdateContainerColor()
	end)
	
	--Set up the expanding.
	local DB = true
	local LastClickTime
	Arrow.MouseButton1Down:Connect(function()
		if DB and not self.Disabled then
			DB = false
			self.Expanded = not self.Expanded
			
			wait()
			DB = true
		end
	end)
	
	--Set up selecting.
	Container.InputBegan:Connect(function(Input)
		if DB and self.Selectable and not self.Disabled and Input.UserInputType == Enum.UserInputType.MouseButton1 then
			DB = false
			if self.Selected then
				--Handle double clicking and delayed clicking.
				if LastClickTime ~= nil then
					if tick() - LastClickTime &lt; DOUBLE_CLICK_MAX_TIME then
						self.DoubleClicked:Fire()
					else
						self.DelayClicked:Fire()
					end
					LastClickTime = nil
				else
					LastClickTime = tick()
				end
				
				wait()
			else
				self.Selected = true
				LastClickTime = tick()
			end
			
			wait()
			DB = true
		end
	end)
	
	--Set up pressing enter.
	self:ConnectToHighestParent("InputBegan",function(Input)
		if self.Selected and Input.KeyCode == Enum.KeyCode.Return then
			self.DoubleClicked:Fire()
		end
	end)
	
	--Set the defaults.
	self.Size = UDim2.new(0,200,0,16)
	self.HighlightColor3 = "TableItem"
	self.BackgroundTransparency = 1
	self.ArrowVisible = true
	self.Selectable = true
	self.Selected = false
	self.Expanded = true
end

--[[
Returns the container that is next to the arrow and
is not collapsed.
--]]
function NexusCollapsableListFrame:GetMainContainer()
	return self.__Container
end

--[[
Returns the collapsable container frame. Frames
parented to this will be shown or hidden based on
if the frame is expanded or collapsed.
--]]
function NexusCollapsableListFrame:GetCollapsableContainer()
	return self.__CollapsableContainer
end



return NexusCollapsableListFrame</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="34">
            <Properties>
              <string name="Name">Constraint</string>
            </Properties>
            <Item class="ModuleScript" referent="35">
              <Properties>
                <string name="Name">NexusBoundingSizeConstraint</string>
                <string name="Source">--[[
TheNexusAvenger

Constraint that is applied to a frame to set the
size as a bounding size.
--]]

local CLASS_NAME = "NexusBoundingSizeConstraint"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusContainer = NexusPluginFramework:GetResource("Base.NexusContainer")

local NexusBoundingSizeConstraint = NexusContainer:Extend()
NexusBoundingSizeConstraint:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusBoundingSizeConstraint)



--[[
Creates a Nexus Bounding Size Constraint object.
--]]
function NexusBoundingSizeConstraint:__new(Frame)
	self:InitializeSuper()
	self.Name = CLASS_NAME
	
	local FrameConnections = {}
	self.FrameConnections = FrameConnections
	local SizeXOverride,SizeYOverride
	local BoundingFrameX,BoundingFrameY
	local SecondaryBoundingFrameX,SecondaryBoundingFrameY
	local BoundingSizeX,BoundingSizeY = 0,0
	local SecondBoundingSizeX,SecondBoundingSizeY = 0,0
	
	--Unwrap the frame.
	if Frame:IsA(NexusContainer.ClassName) then
		Frame = Frame:GetWrappedInstance()
	end
	
	--[[
	Returns the corner position of the frame.
	--]]
	local function GetCornerPosition(Frame)
		local AbsoluteSize,AbsolutePosition = Frame.AbsoluteSize,Frame.AbsolutePosition
		local SizeX,SizeY = AbsoluteSize.X,AbsoluteSize.Y
		local PosX,PosY = AbsolutePosition.X,AbsolutePosition.Y
		
		--Add to the PosX and PosY.
		if SizeX > 0 then
			PosX = PosX + SizeX
		end
		if SizeY > 0 then
			PosY = PosY + SizeY
		end
		
		--Return the corner.
		return PosX,PosY
	end
	
	--[[
	Returns the visible frames.
	--]]
	local function GetVisibleFrames(ReferenceFrame,IgnoreFirstCheck)
		local Frames = {}
		
		--Return if the frame is invisible.
		if IgnoreFirstCheck ~= true and not ReferenceFrame.Visible then
			return {}
		end
		
		--Get the frames.
		table.insert(Frames,ReferenceFrame)
		for _,SubFrame in pairs(ReferenceFrame:GetChildren()) do
			if SubFrame:IsA("Frame") and SubFrame.Visible then
				for _,ChildFrame in pairs(GetVisibleFrames(SubFrame)) do
					table.insert(Frames,ChildFrame)
				end
			end
		end
		
		--Return the frames.
		return Frames
	end
	
	--[[
	Recalculates the bounding size of the frame.
	--]]
	local function RecalculateBoundingSize()
		--Return the size if both overrides are set.
		if SizeXOverride and SizeYOverride then
			return
		end
		
		--Get the starting position.
		local StartingPosX,StartingPosY = Frame.AbsolutePosition.X,Frame.AbsolutePosition.Y
		local MaxPosX,MaxPosY = StartingPosX,StartingPosY
		local SecondMaxPosX,SecondMaxPosY = StartingPosX,StartingPosY
		local NewBoundingFrameX,NewBoundingFrameY
		
		--Set the max position.
		for _,SubFrame in pairs(GetVisibleFrames(Frame,true)) do
			if SubFrame.Visible and SubFrame ~= Frame then
				local CornerPosX,CornerPosY = GetCornerPosition(SubFrame)
				
				--Update the max size X.
				if not SizeXOverride then
					if CornerPosX > MaxPosX then
						if MaxPosX > SecondMaxPosX then
							SecondMaxPosX = MaxPosX
							SecondaryBoundingFrameX = BoundingFrameX
						end
						MaxPosX = CornerPosX
						BoundingFrameX = SubFrame
					elseif CornerPosX > SecondMaxPosX then
						SecondMaxPosX = CornerPosX
					end
				end
				
				--Update the max size Y.
				if not SizeYOverride then
					if CornerPosY > MaxPosY then
						if MaxPosY > SecondMaxPosY then
							SecondMaxPosY = MaxPosY
							SecondaryBoundingFrameY = BoundingFrameY
						end
						MaxPosY = CornerPosY
					elseif CornerPosY > SecondMaxPosY then
						SecondMaxPosY = CornerPosY
						BoundingFrameY = SubFrame
					end
				end
			end
		end
		
		--Set the bounding size.
		SecondBoundingSizeX,SecondBoundingSizeY = SecondMaxPosX - StartingPosX,SecondMaxPosY - StartingPosY
		BoundingSizeX,BoundingSizeY = MaxPosX - StartingPosX,MaxPosY - StartingPosY
	end
	
	--[[
	Updates the bounding size.
	--]]
	local function UpdateBoundingSize()
		Frame.Size = UDim2.new(SizeXOverride or UDim.new(0,BoundingSizeX),SizeYOverride or UDim.new(0,BoundingSizeY))
	end
	
	--[[
	Disconnects the events when a frame is removed.
	--]]
	local function FrameRemoved(SubFrame)
		--Disconnect the connections.
		local Connections = FrameConnections[SubFrame]
		if Connections then
			for _,Connection in pairs(Connections) do
				Connection:Disconnect()
			end
			FrameConnections[SubFrame] = nil
		end
		
		--Update the bounding size.
		RecalculateBoundingSize()
		UpdateBoundingSize()
	end
	
	--[[
	Adds a new frame to track.
	--]]
	local function FrameAdded(SubFrame)
		if SubFrame:IsA("Frame") and not FrameConnections[SubFrame] then
			local LastSizeX,LastSizeY
			local LastPosX,LastPosY
			
			--[[
			Updates the size if it changes.
			--]]
			local function UpdateSize()
				--Get the current size.
				local Size,Position = SubFrame.Size,SubFrame.Position
				local SizeX,SizeY = Size.X,Size.Y
				local PosX,PosY = Position.X,Position.Y
				
				--Return if the non-overriden size hasn't changed.
				if (SizeXOverride and SizeYOverride) or (SizeX == LastSizeX and PosX == LastPosX and SizeYOverride) or (SizeY == LastSizeY and PosY == LastPosY and SizeXOverride) then
					return
				end
				
				--Update the last size.
				LastSizeX = SizeX
				LastSizeY = SizeY
				LastPosX = PosX
				LastPosY = PosY
				
				--Change the bounding size.
				local CornerPosX,CornerPosY = GetCornerPosition(SubFrame)
				local AbsoluteSizeX,AbsoluteSizeY = CornerPosX - Frame.AbsolutePosition.X,CornerPosY - Frame.AbsolutePosition.Y
				local RecalculateX,RecalculateY = false,false
				if SubFrame == BoundingFrameX then
					if AbsoluteSizeX > SecondBoundingSizeX then
						BoundingSizeX = AbsoluteSizeX
					else
						RecalculateX = true
					end
				elseif SubFrame == SecondaryBoundingFrameX then
					if AbsoluteSizeX > BoundingSizeX then
						SecondBoundingSizeX = BoundingSizeX
						BoundingSizeX = AbsoluteSizeX
					elseif AbsoluteSizeX &lt; SecondBoundingSizeX then
						RecalculateX = true
					end
				elseif AbsoluteSizeX > BoundingSizeX then
					RecalculateX = true
				end
				
				if SubFrame == BoundingFrameY then
					if AbsoluteSizeY > SecondBoundingSizeY then
						BoundingSizeY = AbsoluteSizeY
					else
						RecalculateY = true
					end
				elseif SubFrame == SecondaryBoundingFrameY then
					if AbsoluteSizeY > BoundingSizeY then
						SecondBoundingSizeY = BoundingSizeY
						BoundingSizeY = AbsoluteSizeY
					elseif AbsoluteSizeY &lt; SecondBoundingSizeY then
						RecalculateY = true
					end
				elseif AbsoluteSizeY > BoundingSizeY then
					RecalculateY = true
				end
				
				--Recalculate the bounding size if needed.
				if RecalculateX or RecalculateY then
					RecalculateBoundingSize()
				end
				
				--Update the bouding size.
				RecalculateBoundingSize()
				UpdateBoundingSize()
			end
			
			--[[
			Force-recalculates the size.
			--]]
			local function ForceRecalculateSize()
				RecalculateBoundingSize()
				UpdateBoundingSize()
			end
			
			--Add the connections.
			local Connections = {}
			local SizeManuallyChanged = false
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("Visible"):Connect(ForceRecalculateSize))
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("AbsoluteRotation"):Connect(UpdateSize)) --Hack that allows for updates with List Constraints
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("AnchorPoint"):Connect(UpdateSize))
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("Position"):Connect(UpdateSize))
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				if not SizeManuallyChanged then
					UpdateSize()
				else
					SizeManuallyChanged = true
				end
			end))
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("Size"):Connect(function()
				SizeManuallyChanged = true
				UpdateSize()
			end))
			table.insert(Connections,SubFrame:GetPropertyChangedSignal("Parent"):Connect(function()
				if not SubFrame:IsDescendantOf(Frame) then
					FrameRemoved(SubFrame)
				else
					ForceRecalculateSize()
				end
			end))
			
			--Store the connections.
			FrameConnections[SubFrame] = Connections
		end
	end
	
	--Set up the connections for adding/removing frames.
	self.DescendantAddedConnection = Frame.DescendantAdded:Connect(function(Frame)
		FrameAdded(Frame)
		RecalculateBoundingSize()
		UpdateBoundingSize()
	end)
	
	--Set up the connections for overrides.
	self.SizeXOverrideConnection = self:GetPropertyChangedSignal("SizeXOverride"):Connect(function()
		SizeXOverride = self.SizeXOverride
		RecalculateBoundingSize()
		UpdateBoundingSize()
	end)
	self.SizeYOverrideConnection = self:GetPropertyChangedSignal("SizeYOverride"):Connect(function()
		SizeYOverride = self.SizeYOverride
		RecalculateBoundingSize()
		UpdateBoundingSize()
	end)
	
	--Add the frames.
	for _,Frame in pairs(Frame:GetDescendants()) do
		FrameAdded(Frame)
	end
	
	--Resize the frame.
	RecalculateBoundingSize()
	UpdateBoundingSize()
end

--[[
Destroys the constraint.
--]]
function NexusBoundingSizeConstraint:Destroy()
	--Disconnect the connections.
	self.DescendantAddedConnection:Disconnect()
	self.SizeXOverrideConnection:Disconnect()
	self.SizeYOverrideConnection:Disconnect()
	local Frames = {}
	for Frame,FrameConnections in pairs(self.FrameConnections) do
		table.insert(Frames,Frame)
		for _,Connection in pairs(FrameConnections) do
			Connection:Disconnect()
		end
	end
	
	--Clear the connections.
	for _,Frame in pairs(Frames) do
		self.FrameConnections[Frame] = nil
	end
end



return NexusBoundingSizeConstraint</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="36">
            <Properties>
              <string name="Name">Input</string>
            </Properties>
            <Item class="Folder" referent="37">
              <Properties>
                <string name="Name">Abstract</string>
              </Properties>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">NexusGuiButton</string>
                  <string name="Source">--[[
TheNexusAvenger

Gui button that disables auto button colors when disabled.
Class is abstract, so it should not be called directly.
--]]

local CLASS_NAME = "NexusGuiButton"



local NexusPluginFramework = require(script.Parent.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")

local NexusGuiButton = NexusWrappedInstance:Extend()
NexusGuiButton:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusGuiButton)



--[[
Creates a Nexus Gui Button object.
--]]
function NexusGuiButton:__new(ButtonClassName)
	self:InitializeSuper(ButtonClassName)
	self.Name = CLASS_NAME
	
	--Set up auto button color disabling.
	self:GetPropertyChangedSignal("Disabled"):Connect(function()
		self.AutoButtonColor = not self.Disabled
	end)
end



return NexusGuiButton</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="39">
              <Properties>
                <string name="Name">NexusCheckBox</string>
                <string name="Source">--[[
TheNexusAvenger

Frame that adds checkbox functionality.
--]]

local CLASS_NAME = "NexusCheckBox"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusObject = NexusPluginFramework:GetResource("NexusInstance.NexusObject")
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusEnums = NexusPluginFramework:GetResource("Data.Enum.NexusEnumCollection").GetBuiltInEnums()

local NexusCheckBox = NexusWrappedInstance:Extend()
NexusCheckBox:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusCheckBox)



--[[
Creates a Nexus Check Box object.
--]]
function NexusCheckBox:__new()
	self:InitializeSuper("Frame")
	self.Name = CLASS_NAME
	self.BorderSizePixel = 1
	
	--Create the frames.
	local Checkmark = NexusWrappedInstance.GetInstance("ImageLabel")
	Checkmark.Hidden = true
	Checkmark.Size = UDim2.new(1 * 0.9,0,1.4 * 0.9,0)
	Checkmark.Position = UDim2.new(0,0,-0.1,0)
	Checkmark.BackgroundTransparency = 1
	Checkmark.Image = "rbxasset://textures/ui/LuaChat/icons/ic-check.png"
	Checkmark.Visible = false
	Checkmark.Parent = self
	
	local MixedFill = NexusWrappedInstance.GetInstance("Frame")
	MixedFill.Hidden = true
	MixedFill.Size = UDim2.new(0.9,0,0.9,0)
	MixedFill.AnchorPoint = Vector2.new(0.5,0.5)
	MixedFill.Position = UDim2.new(0.5,0,0.5,0)
	MixedFill.BorderSizePixel = 0
	MixedFill.Visible = false
	MixedFill.Parent = self:GetWrappedInstance()
	
	--Set up the non-frame colors.
	self:__SetChangedOverride("CheckColor3",function()
		Checkmark.ImageColor3 = self.CheckColor3
	end)
	
	self:__SetChangedOverride("MixedColor3",function()
		MixedFill.BackgroundColor3 = self.MixedColor3
	end)
	
	--Set up the state changes.
	self:__SetChangedOverride("BoxState",function()
		Checkmark.Visible = NexusEnums.CheckBoxState.Checked:Equals(self.BoxState)
		MixedFill.Visible = NexusEnums.CheckBoxState.Mixed:Equals(self.BoxState)
		self.Selected = NexusEnums.CheckBoxState.Checked:Equals(self.BoxState)
	end)
	
	--Set up user input.
	self.InputBegan:Connect(function(Input)
		--Return if the frame isn't enabled.
		if not self:IsEnabled() then
			return
		end
		
		--If the mouse button was pressed, toggle the button.
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then
			self:Toggle()
		end
	end)
	
	--Initialize the initial state.
	self.BoxState = NexusEnums.CheckBoxState.Unchecked
	
	--Initialize the colors.
	self.BackgroundColor3 = "CheckedFieldBackground"
	self.BorderColor3 = "CheckedFieldBorder"
	self.CheckColor3 = "CheckedFieldIndicator"
	self.MixedColor3 = "CheckedFieldIndicator"
end

--[[
Toggles the checkbox.
--]]
function NexusCheckBox:Toggle()
	if NexusEnums.CheckBoxState.Unchecked:Equals(self.BoxState) then
		self.BoxState = NexusEnums.CheckBoxState.Checked
	else
		self.BoxState = NexusEnums.CheckBoxState.Unchecked
	end
end



return NexusCheckBox</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="40">
              <Properties>
                <string name="Name">NexusImageButton</string>
                <string name="Source">--[[
TheNexusAvenger

Image button that disables auto button colors when disabled.
--]]

local CLASS_NAME = "NexusImageButton"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusGuiButton = NexusPluginFramework:GetResource("UI.Input.Abstract.NexusGuiButton")

local NexusImageButton = NexusGuiButton:Extend()
NexusImageButton:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusImageButton)



--[[
Creates a Nexus Image Box object.
--]]
function NexusImageButton:__new()
	self:InitializeSuper("ImageButton")
	self.Name = CLASS_NAME
	
	--Set the defaults.
	self.BackgroundColor3 = "Button"
	self.BorderColor3 = "ButtonBorder"
end



return NexusImageButton</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="41">
              <Properties>
                <string name="Name">NexusTextBox</string>
                <string name="Source">--[[
TheNexusAvenger

Text box that disables input functionality when disabled.
--]]

local CLASS_NAME = "NexusTextBox"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")

local NexusTextBox = NexusWrappedInstance:Extend()
NexusTextBox:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusTextBox)



--[[
Creates a Nexus Text Box object.
--]]
function NexusTextBox:__new()
	self:InitializeSuper("TextBox")
	self.Name = CLASS_NAME
	
	--Set up input disabling.
	self:GetPropertyChangedSignal("Disabled"):Connect(function()
		if self.Disabled then
			self:ReleaseFocus()
		end
	end)
	
	self.Focused:Connect(function()
		if self.Disabled then
			self:ReleaseFocus()
		end
	end)
	
	--Set the defaults.
	self.BackgroundColor3 = "InputFieldBackground"
	self.BorderColor3 = "InputFieldBorder"
	self.TextColor3 = "MainText"
	self.PlaceholderColor3 = "DimmedText"
	self.TextXAlignment = "Left"
	self.Font = "SourceSans"
	self.TextSize = 14
	self.ClearTextOnFocus = false
	self.ClipsDescendants = true
end



return NexusTextBox</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="42">
              <Properties>
                <string name="Name">NexusTextButton</string>
                <string name="Source">--[[
TheNexusAvenger

Text button that disables auto button colors when disabled.
--]]

local CLASS_NAME = "NexusTextButton"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusGuiButton = NexusPluginFramework:GetResource("UI.Input.Abstract.NexusGuiButton")

local NexusTextBox = NexusGuiButton:Extend()
NexusTextBox:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusTextBox)



--[[
Creates a Nexus Text Box object.
--]]
function NexusTextBox:__new()
	self:InitializeSuper("TextButton")
	self.Name = CLASS_NAME
	
	--Set the defaults.
	self.BackgroundColor3 = "Button"
	self.BorderColor3 = "ButtonBorder"
	self.TextColor3 = "ButtonText"
	self.Font = "SourceSans"
	self.TextSize = 14
end



return NexusTextBox</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="43">
            <Properties>
              <string name="Name">Scroll</string>
            </Properties>
            <Item class="ModuleScript" referent="44">
              <Properties>
                <string name="Name">NexusScrollBar</string>
                <string name="Source">--[[
TheNexusAvenger

Frame that adds scroll frame functionality
--]]

local CLASS_NAME = "NexusScrollBar"

local SCROLL_BUTTON_HOLD_TIME = 0.5
local SCROLL_BUTTON_HOLD_STEPS_PER_SECOND = 20

local SCROLL_BUTTON_IMAGE_UP = "rbxasset://textures/ui/Lobby/Buttons/scroll_up.png"
local SCROLL_BUTTON_IMAGE_DOWN = "rbxasset://textures/ui/Lobby/Buttons/scroll_down.png"
local SCROLL_BUTTON_IMAGE_LEFT = "rbxasset://textures/ui/Lobby/Buttons/scroll_left.png"
local SCROLL_BUTTON_IMAGE_RIGHT = "rbxasset://textures/ui/Lobby/Buttons/scroll_right.png"



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusEventCreator = NexusPluginFramework:GetResource("NexusInstance.Event.NexusEventCreator")
local NexusObject = NexusPluginFramework:GetResource("NexusInstance.NexusObject")
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusEnums = NexusPluginFramework:GetResource("Data.Enum.NexusEnumCollection").GetBuiltInEnums()

local NexusScrollBar = NexusWrappedInstance:Extend()
NexusScrollBar:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusScrollBar)



--[[
Returns if a position is in a frame.
--]]
local function PointInFrame(X,Y,Frame)
	local AbsoluteSize,AbsolutePosition = Frame.AbsoluteSize,Frame.AbsolutePosition
	return X >= AbsolutePosition.X and X &lt;= AbsolutePosition.X + AbsoluteSize.X and Y >= AbsolutePosition.Y and Y &lt;= AbsolutePosition.Y + AbsoluteSize.Y
end



--[[
Creates a Nexus Scrolling Bar object.
--]]
function NexusScrollBar:__new(Theme,Axis)
	self:InitializeSuper("Frame")
	self.Name = CLASS_NAME
	self.__StartPosition = 0
	self.__EndPosition = 0
	
	--Create the events.
	self:__SetChangedOverride("Button1Pressed",function() end)
	self.Button1Pressed = NexusEventCreator:CreateEvent()
	self:__SetChangedOverride("Button2Pressed",function() end)
	self.Button2Pressed = NexusEventCreator:CreateEvent()
	
	--Create the scroll bar.
	local ScrollBar = NexusWrappedInstance.GetInstance("Frame")
	ScrollBar.BorderSizePixel = 1
	ScrollBar.Name = "ScrollBar"
	ScrollBar.Hidden = true
	ScrollBar.Parent = self
	self.__ScrollBar = ScrollBar
	
	--Create the buttons.
	local Button1 = NexusWrappedInstance.GetInstance("TextButton")
	Button1.Hidden = true
	Button1.Name = "Button1"
	Button1.Text = ""
	Button1.Parent = self
	self.__Button1 = Button1
	
	local Button2 = NexusWrappedInstance.GetInstance("TextButton")
	Button2.Hidden = true
	Button2.Name = "Button2"
	Button2.Text = ""
	Button2.Parent = self
	self.__Button2 = Button2
	
	--Apply the themes.
	self:__ApplyQt5Theme(Axis)
	
	--Set up updating the size.
	local UpdateScrollBar
	if Axis == Enum.Axis.X then
		function UpdateScrollBar()
			--Get the sizes and positions.
			local AbsoluteSize = self.AbsoluteSize
			local StartPosition,EndPosition = self.__StartPosition,self.__EndPosition
			local RelativePosition,RelativeSize = self.RelativePosition or 0,self.RelativeSize or 1
	 
			--Adjust the size.
			if RelativeSize &lt; 1 then
				RelativeSize = 1
			end
			
			--Determine the scroll bar size and position.
			local ScrollBarSize = (EndPosition - StartPosition)/RelativeSize
			local ScrollBarOffset = RelativePosition * ((EndPosition - StartPosition) - ScrollBarSize)
			
			--Set the size and position of the scroll bar.
			ScrollBar.Size = UDim2.new(0,ScrollBarSize,1,0)
			ScrollBar.Position = UDim2.new(0,StartPosition + ScrollBarOffset,0,0)
		end
	elseif Axis == Enum.Axis.Y then
		function UpdateScrollBar()
			--Get the sizes and positions.
			local AbsoluteSize = self.AbsoluteSize
			local StartPosition,EndPosition = self.__StartPosition,self.__EndPosition
			local RelativePosition,RelativeSize = self.RelativePosition or 0,self.RelativeSize or 1
	 
			--Adjust the size.
			if RelativeSize &lt; 1 then
				RelativeSize = 1
			end
			
			--Determine the scroll bar size and position.
			local ScrollBarSize = (EndPosition - StartPosition)/RelativeSize
			local ScrollBarOffset = RelativePosition * ((EndPosition - StartPosition) - ScrollBarSize)
			
			--Set the size and position of the scroll bar.
			ScrollBar.Size = UDim2.new(1,0,0,ScrollBarSize)
			ScrollBar.Position = UDim2.new(0,0,0,StartPosition + ScrollBarOffset)
		end
	end
	self:__SetChangedOverride("RelativePosition",UpdateScrollBar)
	self:__SetChangedOverride("RelativeSize",UpdateScrollBar)
	self:GetPropertyChangedSignal("__StartPosition"):Connect(UpdateScrollBar)
	self:GetPropertyChangedSignal("__EndPosition"):Connect(UpdateScrollBar)
	
	--Set up the buttons.
	local Button1Start,Button2Start
	local Button1LastInvoke,Button2LastInvoke
	Button1.MouseButton1Down:Connect(function()
		--Fire the first invoke.
		self.Button1Pressed:Fire()
		Button1Start = tick()
		Button1LastInvoke = tick()
		
		--Run the loop until the mouse button is released.
		while Button1Start do
			local CurrentTime = tick()
			if CurrentTime - Button1Start >= SCROLL_BUTTON_HOLD_TIME and CurrentTime - Button1LastInvoke >= 1/SCROLL_BUTTON_HOLD_STEPS_PER_SECOND then
				self.Button1Pressed:Fire()
				Button1LastInvoke = CurrentTime
			end
			wait()
		end
	end)

	Button1.MouseButton1Up:Connect(function()
		Button1Start = nil
	end)
	
	Button2.MouseButton1Down:Connect(function()
		--Fire the first invoke.
		self.Button2Pressed:Fire()
		Button2Start = tick()
		Button2LastInvoke = tick()
		
		--Run the loop until the mouse button is released.
		while Button2Start do
			local CurrentTime = tick()
			if CurrentTime - Button2Start >= SCROLL_BUTTON_HOLD_TIME and CurrentTime - Button2LastInvoke >= 1/SCROLL_BUTTON_HOLD_STEPS_PER_SECOND then
				self.Button2Pressed:Fire()
				Button2LastInvoke = CurrentTime
			end
			wait()
		end
	end)

	Button2.MouseButton1Up:Connect(function()
		Button2Start = nil
	end)
	
	--Set up dragging.
	local StartPosition,LastPosition
	local MoveScrollBar
	if Axis == Enum.Axis.X then
		function MoveScrollBar(CurrentPosition)
			--Determine the delta.
			local DeltaX = CurrentPosition.X - LastPosition.X
			local ScrollBarSize = self.__EndPosition - self.__StartPosition
			local EmptySpace = ScrollBarSize * (1 - (1/self.RelativeSize))
			
			--Add the delta.
			self.RelativePosition = math.clamp(self.RelativePosition + (DeltaX/EmptySpace),0,1)
			
			--Set the last position as the next position.
			LastPosition = CurrentPosition
		end
	elseif Axis == Enum.Axis.Y then
		function MoveScrollBar(CurrentPosition)
			--Determine the delta.
			local DeltaY = CurrentPosition.Y - LastPosition.Y
			local ScrollBarSize = self.__EndPosition - self.__StartPosition
			local EmptySpace = ScrollBarSize * (1 - (1/self.RelativeSize))
			
			--Add the delta.
			self.RelativePosition = math.clamp(self.RelativePosition + (DeltaY/EmptySpace),0,1)
			
			--Set the last position as the next position.
			LastPosition = CurrentPosition
		end
	end
	
	ScrollBar:ConnectToHighestParent("InputBegan",function(Input)
		if Input.UserInputType == Enum.UserInputType.MouseButton1 and PointInFrame(Input.Position.X,Input.Position.Y,ScrollBar) then
			StartPosition = Input.Position
			LastPosition = StartPosition
		end
	end)
	
	ScrollBar:ConnectToHighestParent("InputChanged",function(Input)
		if StartPosition and Input.UserInputType == Enum.UserInputType.MouseMovement then
			MoveScrollBar(Input.Position)
		end
	end)
	
	ScrollBar:ConnectToHighestParent("InputEnded",function(Input)
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then
			StartPosition = nil
			LastPosition = nil
		end
	end)
	
	--Set the default colors.
	self.BackgroundColor3 = "ScrollBarBackground"
	self.BorderColor3 = "Border"
	self.ScrollColor3 = "ScrollBar"
	self.ScrollArrowColor3 = "TitlebarText"
	self.BorderSizePixel = 1
	
	--Set the size.
	self.RelativePosition = 0
	self.RelativeSize = 2
	if Axis == Enum.Axis.X then
		self.Size = UDim2.new(0,200,0,50)
	elseif Axis == Enum.Axis.Y then
		self.Size = UDim2.new(0,50,0,200)
	end
end

--[[
Applies the Qt5 theme to the scroll bar.
--]]
function NexusScrollBar:__ApplyQt5Theme(Axis)
	--Modify the scroll frame.
	local ScrollBar = self.__ScrollBar
	ScrollBar.BorderSizePixel = 1
	
	--Modify the buttons.
	local Button1 = self.__Button1
	Button1.BorderColor3 = "Border"
	Button1.Size = UDim2.new(1,0,1,0)
	if Axis == Enum.Axis.X then
		Button1.SizeConstraint = Enum.SizeConstraint.RelativeYY
	elseif Axis == Enum.Axis.Y then
		Button1.SizeConstraint = Enum.SizeConstraint.RelativeXX
	end
	
	local Arrow1 = NexusWrappedInstance.GetInstance("ImageLabel")
	Arrow1.Hidden = true
	Arrow1.BackgroundTransparency = 1
	Arrow1.Position = UDim2.new(0.5,0,0.5,0)
	Arrow1.AnchorPoint = Vector2.new(0.5,0.5)
	Arrow1.Parent = Button1
	if Axis == Enum.Axis.X then
		Arrow1.Image = SCROLL_BUTTON_IMAGE_LEFT
		Arrow1.Size = UDim2.new(6/16,0,10/16,0)
	elseif Axis == Enum.Axis.Y then
		Arrow1.Image = SCROLL_BUTTON_IMAGE_UP
		Arrow1.Size = UDim2.new(10/16,0,6/16,0)
	end
	
	local Button2 = self.__Button2
	Button2.BorderColor3 = "Border"
	Button2.Size = UDim2.new(1,0,1,0)
	Button2.AnchorPoint = Vector2.new(1,1)
	Button2.Position = UDim2.new(1,0,1,0)
	if Axis == Enum.Axis.X then
		Button2.SizeConstraint = Enum.SizeConstraint.RelativeYY
	elseif Axis == Enum.Axis.Y then
		Button2.SizeConstraint = Enum.SizeConstraint.RelativeXX
	end
	
	local Arrow2 = NexusWrappedInstance.GetInstance("ImageLabel")
	Arrow2.Hidden = true
	Arrow2.BackgroundTransparency = 1
	Arrow2.Position = UDim2.new(0.5,0,0.5,0)
	Arrow2.AnchorPoint = Vector2.new(0.5,0.5)
	Arrow2.Parent = Button2
	if Axis == Enum.Axis.X then
		Arrow2.Image = SCROLL_BUTTON_IMAGE_RIGHT
		Arrow2.Size = UDim2.new(6/16,0,10/16,0)
	elseif Axis == Enum.Axis.Y then
		Arrow2.Image = SCROLL_BUTTON_IMAGE_DOWN
		Arrow2.Size = UDim2.new(10/16,0,6/16,0)
	end
	
	--Set up colors.
	self:GetPropertyChangedSignal("BorderColor3"):Connect(function()
		ScrollBar.BorderColor3 = self.BorderColor3
		Button1.BorderColor3 = self.BorderColor3
		Button2.BorderColor3 = self.BorderColor3
	end)
	
	self:GetPropertyChangedSignal("BorderSizePixel"):Connect(function()
		ScrollBar.BorderSizePixel = self.BorderSizePixel
		Button1.BorderSizePixel = self.BorderSizePixel
		Button2.BorderSizePixel = self.BorderSizePixel
	end)
	
	self:__SetChangedOverride("ScrollColor3",function()
		ScrollBar.BackgroundColor3 = self.ScrollColor3
		Button1.BackgroundColor3 = self.ScrollColor3
		Button1.BackgroundColor3 = self.ScrollColor3
	end)
	
	self:__SetChangedOverride("ScrollArrowColor3",function()
		Arrow1.ImageColor3 = self.ScrollArrowColor3
		Arrow2.ImageColor3 = self.ScrollArrowColor3
	end)
	
	--Set up z-indexing.
	self:GetPropertyChangedSignal("ZIndex"):Connect(function()
		local ZIndex = self.ZIndex
		ScrollBar.ZIndex = ZIndex
		Button1.ZIndex = ZIndex
		Button2.ZIndex = ZIndex
		Arrow1.ZIndex = ZIndex
		Arrow2.ZIndex = ZIndex
	end)
	
	--Set up resizing.
	local ResizeFunction
	if Axis == Enum.Axis.X then
		function ResizeFunction()
			--Get the size.
			local AbsoluteSize = self.AbsoluteSize
			local FullLength = AbsoluteSize.X
			local ButtonSizeRequirement = AbsoluteSize.Y + self.BorderSizePixel
			
			--Update the buttons.
			local RemainingLength = FullLength - (2 * ButtonSizeRequirement)
			if RemainingLength > 0 then
				Button1.Visible = true
				Button2.Visible = true
				
				self.__StartPosition = ButtonSizeRequirement
				self.__EndPosition = ButtonSizeRequirement + RemainingLength
			else
				Button1.Visible = false
				Button2.Visible = false
				
				self.__StartPosition = 0
				self.__EndPosition = FullLength
			end
		end
	elseif Axis == Enum.Axis.Y then
		function ResizeFunction()
			--Get the size.
			local AbsoluteSize = self.AbsoluteSize
			local FullLength = AbsoluteSize.Y
			local ButtonSizeRequirement = AbsoluteSize.X + self.BorderSizePixel
			
			--Update the buttons.
			local RemainingLength = FullLength - (2 * ButtonSizeRequirement)
			if RemainingLength > 0 then
				Button1.Visible = true
				Button2.Visible = true
				
				self.__StartPosition = ButtonSizeRequirement
				self.__EndPosition = ButtonSizeRequirement + RemainingLength
			else
				Button1.Visible = false
				Button2.Visible = false
				
				self.__StartPosition = 0
				self.__EndPosition = FullLength
			end
		end
	end
	self:GetPropertyChangedSignal("AbsoluteSize"):Connect(ResizeFunction)
	self:GetPropertyChangedSignal("BorderSizePixel"):Connect(ResizeFunction)
end



return NexusScrollBar</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="45">
              <Properties>
                <string name="Name">NexusScrollingFrame</string>
                <string name="Source">--[[
TheNexusAvenger

Frame that allows for scrolling. Can have one of multiple themes.
--]]

local CLASS_NAME = "NexusScrollingFrame"

local SCROLL_BUTTON_HOLD_TIME = 0.5
local SCROLL_BUTTON_HOLD_STEPS_PER_SECOND = 10



local NexusPluginFramework = require(script.Parent.Parent.Parent:WaitForChild("NexusPluginFrameworkProject")):GetContext(script)
local NexusObject = NexusPluginFramework:GetResource("NexusInstance.NexusObject")
local NexusWrappedInstance = NexusPluginFramework:GetResource("Base.NexusWrappedInstance")
local NexusSettings = NexusPluginFramework:GetResource("Plugin.NexusSettings")
local NexusScrollBar = NexusPluginFramework:GetResource("UI.Scroll.NexusScrollBar")
local NexusEnums = NexusPluginFramework:GetResource("Data.Enum.NexusEnumCollection").GetBuiltInEnums()

local NexusScrollingFrame = NexusWrappedInstance:Extend()
NexusScrollingFrame:SetClassName(CLASS_NAME)
NexusPluginFramework:SetContextResource(NexusScrollingFrame)



--[[
Creates a Nexus Scrolling Frame object.
--]]
function NexusScrollingFrame:__new(Theme)
	self:InitializeSuper("ScrollingFrame")
	
	--Modify the theme.
	if not Theme then
		Theme = NexusEnums.NexusScrollTheme.Native
	end
	
	--Initialize the super class.
	if NexusEnums.NexusScrollTheme.Native:Equals(Theme) then
		self:__InitializeNativeScrollingFrame()
	elseif NexusEnums.NexusScrollTheme.Qt5:Equals(Theme) then
		self:__InitializeQt5ScrollingFrame()
	end
	
	--Set the name.
	self.Name = CLASS_NAME
	
	--Set the colors.
	self.BackgroundColor3 = "MainBackground"
	self.BorderColor3 = "Border"
	self.ScrollColor3 = "ScrollBar"
	self.ScrollBackgroundColor3 = "ScrollBarBackground"
	self.ScrollArrowColor3 = "TitlebarText"
	self:__SetChangedOverride("ScrollBarButtonIncrement",function() end)
	self.ScrollBarButtonIncrement = 16
end

--[[
Initializes the scrolling frame as a native one.
--]]
function NexusScrollingFrame:__InitializeNativeScrollingFrame()
	--Set up the color change overrides.
	self:__SetChangedOverride("ScrollColor3",function()
		self.ScrollBarImageColor3 = self.ScrollColor3
	end)
	self:__SetChangedOverride("ScrollBackgroundColor3",function() end)
	self:__SetChangedOverride("ScrollArrowColor3",function() end)
	
	--Set the default properties.
	self.BottomImage = "rbxasset://textures/StudioToolbox/ScrollBarBottom.png"
	self.MidImage = "rbxasset://textures/StudioToolbox/ScrollBarMiddle.png"
	self.TopImage = "rbxasset://textures/StudioToolbox/ScrollBarTop.png"
	self.ScrollBarThickness = 8
end

--[[
Initializes the scrolling frame as a Qt5 one.
--]]
function NexusScrollingFrame:__InitializeQt5ScrollingFrame()
	--Create the adorn.
	local ScrollBarAdorn = NexusWrappedInstance.GetInstance("Frame")
	ScrollBarAdorn.Name = "ScrollBarAdorn"
	ScrollBarAdorn.BackgroundTransparency = 1
	ScrollBarAdorn.Hidden = true
	
	--[[
	Sets up changes to the scroll bar adorn from the frame.
	--]]
	local function MirrorChanges(PropertyName)
		self:GetPropertyChangedSignal(PropertyName):Connect(function()
			ScrollBarAdorn[PropertyName] = self[PropertyName]
		end)
	end
	MirrorChanges("Size")
	MirrorChanges("Position")
	MirrorChanges("Rotation")
	MirrorChanges("Parent")
	
	--Create the side scrollbars.
	local BottomScrollBar = NexusScrollBar.new(NexusEnums.NexusScrollTheme.Qt5,Enum.Axis.X)
	BottomScrollBar.Name = "HorizontalScrollBar"
	BottomScrollBar.Parent = ScrollBarAdorn
	local SideScrollBar = NexusScrollBar.new(NexusEnums.NexusScrollTheme.Qt5,Enum.Axis.Y)
	SideScrollBar.Name = "VerticalScrollBar"
	SideScrollBar.Parent = ScrollBarAdorn
	
	self:GetPropertyChangedSignal("ZIndex"):Connect(function()
		ScrollBarAdorn.ZIndex = self.ZIndex + 1
		BottomScrollBar.ZIndex = self.ZIndex + 1
		SideScrollBar.ZIndex = self.ZIndex + 1
	end)
	ScrollBarAdorn.ZIndex = self.ZIndex + 1
	BottomScrollBar.ZIndex = self.ZIndex + 1
	SideScrollBar.ZIndex = self.ZIndex + 1
	
	--Set up input for the scrollbars.
	--[[
	Returns the absolute size of the canvas.
	--]]
	local function GetAbsoluteCanvasSize()
		--Return 0,0 if there is no parent.
		local Parent = self.Parent
		if not Parent then
			return Vector2.new(0,0)
		end
		
		--Return the absolute size.
		local CanvasSize = self.CanvasSize
		local ParentAbsoluteSize = Parent.AbsoluteSize
		return Vector2.new((CanvasSize.X.Scale * ParentAbsoluteSize.X) + CanvasSize.X.Offset,(CanvasSize.Y.Scale * ParentAbsoluteSize.Y) + CanvasSize.Y.Offset)
	end
	
	--[[
	Updates the position of the scroll bar when the position changes.
	--]]
	local function UpdatePosition()
		local AbsoluteWindowSize = self.AbsoluteWindowSize
		local AbsoluteCanvasSize = GetAbsoluteCanvasSize()
		local ExistingCanvasPosition = self.CanvasPosition
		
		BottomScrollBar.RelativePosition = ExistingCanvasPosition.X / (AbsoluteCanvasSize.X - AbsoluteWindowSize.X)
		SideScrollBar.RelativePosition = ExistingCanvasPosition.Y / (AbsoluteCanvasSize.Y - AbsoluteWindowSize.Y)
	end
	self:GetPropertyChangedSignal("AbsoluteSize"):Connect(UpdatePosition)
	self:GetPropertyChangedSignal("CanvasSize"):Connect(UpdatePosition)
	self:GetPropertyChangedSignal("CanvasPosition"):Connect(UpdatePosition)
	
	--Set up button press events.
	BottomScrollBar.Button1Pressed:Connect(function()
		local ExistingCanvasPosition = self.CanvasPosition
		local ScrollBarButtonIncrement = self.ScrollBarButtonIncrement
		
		self.CanvasPosition = Vector2.new(math.max(0,ExistingCanvasPosition.X - ScrollBarButtonIncrement),ExistingCanvasPosition.Y)
	end)
	
	BottomScrollBar.Button2Pressed:Connect(function()
		local ExistingCanvasPosition = self.CanvasPosition
		local ScrollBarButtonIncrement = self.ScrollBarButtonIncrement
		local AbsoluteWindowSize = self.AbsoluteWindowSize
		local AbsoluteCanvasSize = GetAbsoluteCanvasSize()
		
		self.CanvasPosition = Vector2.new(math.min(ExistingCanvasPosition.X + ScrollBarButtonIncrement,AbsoluteCanvasSize.X - AbsoluteWindowSize.X),ExistingCanvasPosition.Y)
	end)
	
	SideScrollBar.Button1Pressed:Connect(function()
		local ExistingCanvasPosition = self.CanvasPosition
		local ScrollBarButtonIncrement = self.ScrollBarButtonIncrement
		
		self.CanvasPosition = Vector2.new(ExistingCanvasPosition.X,math.max(0,ExistingCanvasPosition.Y - ScrollBarButtonIncrement,0))
	end)
	
	SideScrollBar.Button2Pressed:Connect(function()
		local ExistingCanvasPosition = self.CanvasPosition
		local ScrollBarButtonIncrement = self.ScrollBarButtonIncrement
		local AbsoluteWindowSize = self.AbsoluteWindowSize
		local AbsoluteCanvasSize = GetAbsoluteCanvasSize()
		
		self.CanvasPosition = Vector2.new(ExistingCanvasPosition.X,math.min(ExistingCanvasPosition.Y + ScrollBarButtonIncrement,AbsoluteCanvasSize.Y - AbsoluteWindowSize.Y))
	end)
	
	--Set up resizing and enabling of scroll bars.
	local function Resize()
		local AbsoluteSize,CanvasAbsoluteSize = self.AbsoluteSize,GetAbsoluteCanvasSize()
		local ScrollBarThickness = self.ScrollBarThickness
		local ScrollBarXEnabled,ScrollBarYEnabled = CanvasAbsoluteSize.X > AbsoluteSize.X,CanvasAbsoluteSize.Y > AbsoluteSize.Y
		local BorderSizePixel = self.BorderSizePixel
		
		--Show or hide the scroll bars.
		BottomScrollBar.Visible = ScrollBarXEnabled
		BottomScrollBar.RelativeSize = CanvasAbsoluteSize.X/AbsoluteSize.X
		SideScrollBar.Visible = ScrollBarYEnabled
		SideScrollBar.RelativeSize = CanvasAbsoluteSize.Y/AbsoluteSize.Y
		
		--Move the vertical scroll bar.
		if self.VerticalScrollBarPosition == "Left" or self.VerticalScrollBarPosition == Enum.VerticalScrollBarPosition.Left then
			BottomScrollBar.AnchorPoint = Vector2.new(1,1)
			BottomScrollBar.Position = UDim2.new(1,-BorderSizePixel,1,0)
			SideScrollBar.AnchorPoint = Vector2.new(0,0)
			SideScrollBar.Position = UDim2.new(0,0,0,BorderSizePixel)
		else
			BottomScrollBar.AnchorPoint = Vector2.new(0,1)
			BottomScrollBar.Position = UDim2.new(0,BorderSizePixel,1,0)
			SideScrollBar.AnchorPoint = Vector2.new(1,0)
			SideScrollBar.Position = UDim2.new(1,0,0,BorderSizePixel)
		end
		
		--Resize the scroll bars.
		if ScrollBarXEnabled and not ScrollBarYEnabled then
			BottomScrollBar.Size = UDim2.new(1,-(2 * BorderSizePixel),0,ScrollBarThickness)
		elseif not ScrollBarXEnabled and ScrollBarYEnabled then
			SideScrollBar.Size = UDim2.new(0,ScrollBarThickness,1,-(2 * BorderSizePixel))
		else
			BottomScrollBar.Size = UDim2.new(1,-ScrollBarThickness - (2 * BorderSizePixel),0,ScrollBarThickness)
			SideScrollBar.Size = UDim2.new(0,ScrollBarThickness,1,-ScrollBarThickness - (2 * BorderSizePixel))
		end
	end
	self:GetPropertyChangedSignal("AbsoluteSize"):Connect(Resize)
	self:GetPropertyChangedSignal("CanvasSize"):Connect(Resize)
	self:GetPropertyChangedSignal("ScrollBarThickness"):Connect(Resize)
	self:GetPropertyChangedSignal("VerticalScrollBarPosition"):Connect(Resize)
	
	--Set up the color change overrides.
	self:__SetChangedOverride("ScrollColor3",function()
		BottomScrollBar.ScrollColor3 = self.ScrollColor3
		SideScrollBar.ScrollColor3 = self.ScrollColor3
	end)
	self:__SetChangedOverride("ScrollBackgroundColor3",function()
		BottomScrollBar.BackgroundColor3 = self.ScrollBackgroundColor3
		SideScrollBar.BackgroundColor3 = self.ScrollBackgroundColor3
	end)
	self:__SetChangedOverride("ScrollArrowColor3",function()
		BottomScrollBar.ScrollArrowColor3 = self.ScrollArrowColor3
		SideScrollBar.ScrollArrowColor3 = self.ScrollArrowColor3
	end)
	
	--Set the default properties.
	self.BottomImage = ""
	self.MidImage = ""
	self.TopImage = ""
	self.ScrollBarThickness = 16
end



return NexusScrollingFrame</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="46">
          <Properties>
            <string name="Name">NexusInstance</string>
          </Properties>
          <Item class="Folder" referent="47">
            <Properties>
              <string name="Name">Event</string>
            </Properties>
            <Item class="ModuleScript" referent="48">
              <Properties>
                <string name="Name">LuaEvent</string>
                <string name="Source">--[[
TheNexusAvenger

Implements the NexusEvent interface using
Lua coroutines.
--]]

local CLASS_NAME = "LuaEvent"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("NexusEvent"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local LuaEvent = NexusObject:Extend()
LuaEvent:SetClassName(CLASS_NAME)
LuaEvent:Implements(NexusEvent)



--[[
Creates an event.
--]]
function LuaEvent:__new()
    self:InitializeSuper()
    self.Connections = {}
end

--[[
Invoked when a connection is disconnected.
--]]
function LuaEvent:Disconnected(Connection)
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function LuaEvent:Disconnect()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection,_ in pairs(self.Connections) do
        table.insert(ConnectionsToDisconnect,Connection)
    end
    
    --Disconnect the events.
    for _,Connection in pairs(ConnectionsToDisconnect) do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function LuaEvent:Connect(Function)
    --Create and store the connection.
    local Connection = NexusConnection.new(self,Function)
    self.Connections[Connection] = true
    
    --Return the connection.
    return Connection
end


--[[
Fires the event.
--]]
function LuaEvent:Fire(...)
    local Parameters = {...}
    for Connection,_ in pairs(self.Connections) do
         coroutine.wrap(function()
            Connection:Fire(unpack(Parameters))
         end)()
    end
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function LuaEvent:Wait()
    local Return
    
    --Create the connection.
    local Connection = self:Connect(function(...)
        Return = {...}
    end)
    
    --Wait for the connection to be fired.
    while not Return do wait() end
    
    --Disconnect the connection and return the fired parameters.
    Connection:Disconnect()
    return unpack(Return)
end



return LuaEvent</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="49">
              <Properties>
                <string name="Name">NexusConnection</string>
                <string name="Source">--[[
TheNexusAvenger

Represents an event connection.
--]]

local CLASS_NAME = "NexusConnection"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName(CLASS_NAME)



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new(Event,ConnectionFunction)
    self:InitializeSuper()
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire(...)
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="50">
              <Properties>
                <string name="Name">NexusEvent</string>
                <string name="Source">--[[
TheNexusAvenger

Interface for an event.
--]]

local CLASS_NAME = "NexusEvent"



local NexusObjectFolder = script.Parent.Parent
local NexusInterface = require(NexusObjectFolder:WaitForChild("NexusInterface"))
local NexusEvent = NexusInterface:Extend()
NexusEvent:SetClassName(CLASS_NAME)



--[[
Invoked when a connection is disconnected.
--]]
NexusEvent:MustImplement("Disconnected")

--[[
Establishes a function to be called whenever
the event is raised.
--]]
NexusEvent:MustImplement("Connect")

--[[
Disconnects all connected events.
--]]
NexusEvent:MustImplement("Disconnect")

--[[
Fires the event.
--]]
NexusEvent:MustImplement("Fire")

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
NexusEvent:MustImplement("Wait")



return NexusEvent</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="51">
              <Properties>
                <string name="Name">NexusEventCreator</string>
                <string name="Source">--[[
TheNexusAvenger

Creates events depending on the preferred event
type and if the platform is Roblox. Extra work
is required to actually make Nexus Instance
work in a non-Roblox environment.
--]]

local USE_NON_ROBLOX_EVENTS = false

local CLASS_NAME = "NexusEventCreator"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local LuaEvent = require(script.Parent:WaitForChild("LuaEvent"))
local RobloxEvent = require(script.Parent:WaitForChild("RobloxEvent"))

local NexusEventCreator = NexusObject:Extend()
NexusEventCreator:SetClassName(CLASS_NAME)



--[[
Returns if Roblox events should be used.
--]]
function NexusEventCreator:UseRobloxEvents()
    if USE_NON_ROBLOX_EVENTS then
        return false
    else
        return Instance ~= nil
    end
end

--[[
Creates an event.
--]]
function NexusEventCreator:CreateEvent()
    if NexusEventCreator:UseRobloxEvents() then
        return RobloxEvent.new()
    else
        return LuaEvent.new()
    end
end



return NexusEventCreator</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="52">
              <Properties>
                <string name="Name">RobloxEvent</string>
                <string name="Source">--[[
TheNexusAvenger

Implements the NexusEvent interface using
Roblox's BindableEvents.
--]]

local CLASS_NAME = "RobloxEvent"



local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("NexusEvent"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local RobloxEvent = NexusObject:Extend()
RobloxEvent:SetClassName(CLASS_NAME)
RobloxEvent:Implements(NexusEvent)



--[[
Creates an event.
--]]
function RobloxEvent:__new()
    self:InitializeSuper()
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments,{__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function RobloxEvent:Disconnected(Connection)
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function RobloxEvent:Disconnect()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection,_ in pairs(self.Connections) do
        table.insert(ConnectionsToDisconnect,Connection)
    end
    
    --Disconnect the events.
    for _,Connection in pairs(ConnectionsToDisconnect) do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function RobloxEvent:Connect(Function)
    --Create the connection.
    local Connection = NexusConnection.new(self,Function)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[Arguments] = nil

        --Fire the event.
        Connection:Fire(unpack(Arguments.Arguments,1,Arguments.Total))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end


--[[
Fires the event.
--]]
function RobloxEvent:Fire(...)
    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = {
        Arguments = {...},
        Total = select("#",...),
    }
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function RobloxEvent:Wait()
    --Wait for the event.
    local UUID = self.BindableEvent.Event:Wait()

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[Arguments] = nil
    return unpack(Arguments.Arguments,1,Arguments.Total)
end



return RobloxEvent</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="53">
            <Properties>
              <string name="Name">NexusInstance</string>
              <string name="Source">--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]

local CLASS_NAME = "NexusInstance"



local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEventCreator = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEventCreator"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName(CLASS_NAME)



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new()
    --Set up the base object.
    self:InitializeSuper()
    
    --Set up the internal properties.
    self:__InitInternalProperties()
    
    --Set up the metamethods.
    self:__InitMetaMethods()
end

--[[
Creates an __index metamethod for an object. Used to
setup custom indexing.
--]]
function NexusInstance:__createindexmethod(Object,Class,RootClass)
    --Get the base method.
    local BaseIndexMethod = self.super:__createindexmethod(Object,Class,RootClass)
    
    --Return a wrapped method.
    return function(MethodObject,Index)
        --Return an internal property.
        local InternalProperties = rawget(Object.object,"__InternalProperties")
        if InternalProperties then
            local Value = InternalProperties[Index]
            if Value ~= nil then
                return Value
            end
        end
        
        --Return the base return.
        return BaseIndexMethod(MethodObject,Index)
    end
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEventCreator:CreateEvent()
    self.Changed = self.__ChangedEvent
    
    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent
    
    --Set up custom indexing.
    local Metatable = getmetatable(self.object)
    local ExistingIndex = Metatable.__index
    
    local function index(_,Index)
        --Return the internal property.
        local InternalPropertyValue = rawget(InternalProperties,Index)
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end
        
        --Return the base return.
        return ExistingIndex(self,Index)
    end
    Metatable.__index = index
    
    --Set up changes.
    Metatable.__newindex = function(_,Index,Value)
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end
        
        --Return if the new and old values are the same.
        if index(self,Index) == Value then
            return
        end
        
        --Validate the value.
        for _,Validator in pairs(GenericPropertyValidators) do
            Value = Validator:ValidateChange(self,Index,Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _,Validator in pairs(Validators) do
                Value = Validator:ValidateChange(self,Index,Value)
            end
        end
        
        --Change the property.
        rawset(InternalProperties,Index,Value)
        
        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _,Finalizer in pairs(GenericPropertyFinalizers) do
            Finalizer(Index,Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _,Finalizer in pairs(Finalizers) do
                Finalizer(Index,Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end
        
        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end
        
        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator)
    table.insert(self.__GenericPropertyValidators,Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName,Validator)
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName],Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer)
    table.insert(self.__GenericPropertyFinalizers,Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName,Finalizer)
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName],Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName)
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName)
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName)
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName)
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEventCreator:CreateEvent()
    end
    
    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in pairs(self.__PropertyChanged) do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="54">
            <Properties>
              <string name="Name">NexusInterface</string>
              <string name="Source">--[[
TheNexusAvenger

Provides a function "interface" for dependant classes
to implement.
--]]

--Class name of the object.
local CLASS_NAME = "NexusInterface"



local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusInterface = NexusObject:Extend()
NexusInterface:SetClassName(CLASS_NAME)
NexusInterface.RequiredAttributes = {}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusInterface:__classextended(OtherClass)
    OtherClass.RequiredAttributes = {}
end
    
--[[
Sets an attribute as required for an object.
Although it is intended to be a name of a function,
it can be any type, and can be implemented
after the constructor is run.
--]]
function NexusInterface:MustImplement(Attribute)
    table.insert(self.RequiredAttributes,Attribute)
end

--[[
Returns a list of the missing attributes from
an object based on the interface. If no attributes
are missing, an empty list is returned.
--]]
function NexusInterface:GetMissingAttributes(Object)
    --Get the missing attributes.
    local MissingAttributes = {}
    for _,Attribute in pairs(self.RequiredAttributes) do
        if not Object[Attribute] then
            table.insert(MissingAttributes,Attribute)
        end
    end
    
    --Return the missing attributes.
    return MissingAttributes
end



return NexusInterface</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="55">
            <Properties>
              <string name="Name">NexusObject</string>
              <string name="Source">--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]

--Class name of the object.
local CLASS_NAME = "NexusObject"

--Metamethods to pass through.
local METATABLE_PASSTHROUGH = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



local NexusObject = {
    ClassName = CLASS_NAME,
    Interfaces = {},
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table)
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil
    
    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    
    return String
end

--[[
Returns the first object from the interfaces.
--]]
local function GetFromInterfaces(Object,Class,Index)
    for _,Interface in pairs(Class:GetInterfaces(Class)) do
        local InterfaceReturn = Interface[Index]
        if InterfaceReturn then
            return InterfaceReturn
        end
    end
end



--[[
Creates an instance of a NexusObject. This is used
as a base.
--]]
function NexusObject.new(...)
    --Create the object.
    local self = {}
    self.class = NexusObject
    self.object = self
    
    --Set up the metatable.
    local Metatable = {}
    Metatable.__index = function(_,Index)
        local RawGet = rawget(self,Index)
        if RawGet then
            return RawGet
        end
        
        return NexusObject[Index]
    end
    setmetatable(self,Metatable)
    
    --Add the metamethod passthrough.
    for _,Name in pairs(METATABLE_PASSTHROUGH) do
        Metatable[Name] = function(_,...)
            return self[Name](self,...)
        end
    end
    
    --Run the constructor.
    self:__new(...)
    
    --Return the object.
    return self
end

--[[
Constructor run for the class.
--]]
function NexusObject:__new()
    
end

--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass)
    OtherClass.Interfaces = {}
end

--[[
Creates an __index metamethod for an object. Used to
setup custom indexing.
--]]
function NexusObject:__createindexmethod(Object,Class,RootClass)
    --Set the root class.
    if not RootClass then
        RootClass = Class
    end
    
    --Get the method.
    if Class.super then
        --[[
        Returns the value for an index of an object.
        --]]
        return function(_,Index)
            if Index == "super" then
                --Create a temporary object.
                local TempObject = {}
                TempObject.object = Object
                
                --Set the metatable to redirect the next "super".
                local Metatable = {}
                Metatable.__index = RootClass:__createindexmethod(Object,Class.super,RootClass)
                Metatable.__newindex = function(_,Index,Value)
                    Object[Index] = Value
                end
                setmetatable(TempObject,Metatable)
                
                --Return the temporary object.
                return TempObject
            else
                --Get the normal property from the object or class.
                local RawReturn = rawget(Object,Index)
                if RawReturn ~= nil then
                    return RawReturn
                end
                
                return Class[Index]
            end
        end
    else
        --[[
        Returns the value for an index of an object.
        --]]
        return function(_,Index)
            local RawReturn = rawget(Object,Index)
            if RawReturn ~= nil then
                return RawReturn
            end
            
            return Class[Index]
        end
    end
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring()
    local MemoryAddress = string.sub(RawToString(self),8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject)
    return rawequal(self,OtherObject)
end

--[[
Initializes the super class. The paramters given
by "..." are passed into the constructor of the
super class (__new(...)). It should be called
in the constructor of the class.
--]]
function NexusObject:InitializeSuper(...)
    if self.super then
        self.super:__new(...)
    end
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName)
    self.ClassName = ClassName
end

--[[
Sets the class as implementing a given interface. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:Implements(Interface)
    --Throw an error if the interface isn't an interface.
    if not Interface:IsA("NexusInterface") then
        error(tostring(Interface).." is not an interface.")
    end
    
    --Add the interface.
    table.insert(self.Interfaces,Interface)
end

--[[
Returns a list of the interfaces that the
class implements. This includes ones implemented
by super classes.
--]]
function NexusObject:GetInterfaces()
    --Get the super class's interfaces.
    local Interfaces = {}
    if self.super then
        Interfaces = self.super:GetInterfaces()
    end
    
    --Add the classes interfaces.
    local ClassInterfaces = self.Interfaces
    if ClassInterfaces then
        for _,Interface in pairs(ClassInterfaces) do
             table.insert(Interfaces,Interface)
        end
    end
    
    --Return the interfaces.
    return Interfaces
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName)
    --If the class name matches the class name, return true.
    if self.ClassName == ClassName then
        return true
    end
    
    --If an interface matches the name, return true.
    if self.Interfaces then
        for _,Interface in pairs(self.Interfaces) do
            if Interface:IsA(ClassName) then
                return true
            end
        end
    end
    
    --If a super class exists, return the result of the super.
    if self.super then
        return self.super:IsA(ClassName)
    end
    
    --Return false (no match).
    return false
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend()
    local super = self
    local ExtendedClass = {
        super = super,
    }
    
    --[[
    Creates an instance of the class.
    --]]
    function ExtendedClass.new(...)
        --Create the object.
        local self = {}
        self.class = ExtendedClass
        self.object = self
        
        --Set up the metatable.
        local Metatable = {}
        Metatable.__index = ExtendedClass:__createindexmethod(self,ExtendedClass)
        setmetatable(self,Metatable)
        
        --Add the metamethod passthrough.
        for _,Name in pairs(METATABLE_PASSTHROUGH) do
            Metatable[Name] = function(_,...)
                return self[Name](self,...)
            end
        end
        
        --Run the constructor.
        self:__new(...)
        
        --Determine the missing attributes.
        local MissingAttributes = {}
        for _,Interface in pairs(self:GetInterfaces()) do
            for _,Attribute in pairs(Interface:GetMissingAttributes(self)) do
                table.insert(MissingAttributes,{Interface.ClassName,Attribute})
            end
        end
        
        --Throw an error if missing attributes exist.
        if #MissingAttributes > 0 then
            --Create the message.
            local ErrorMessage = tostring(self.ClassName).." does not implement the following:"
            for _,Attribute in pairs(MissingAttributes) do
                ErrorMessage = ErrorMessage.."\n\t"..tostring(Attribute[1]).."."..tostring(Attribute[2])
            end
            
            --Throw the error.
            error(ErrorMessage)
        end
        
        --Return the object.
        return self
    end
    
    --[[
    Constructor run for the class.
    --]]
    function ExtendedClass:__new(...)
        self:InitializeSuper(...)
    end
    
    --[[
    Called after extending when another class extends
    the class. The purpose of this is to add attributes
    to the class.
    --]]
    function ExtendedClass:__classextended(OtherClass)
        self.super:__classextended(OtherClass)
    end
    
    --Set up the metatable for indexing.
    local Metatable = {}
    Metatable.__index = function(_,Index)
        --Return the value for the class.
        local ClassReturn = rawget(ExtendedClass,Index)
        if ClassReturn ~= nil then
            return ClassReturn
        end
        
        --Return the value for the super classes.
        local SuperClassReturn = super[Index]
        if SuperClassReturn ~= nil then
            return SuperClassReturn
        end
        
        --Return the value for the interfaces.
        return GetFromInterfaces(ExtendedClass,ExtendedClass,Index)
    end
    setmetatable(ExtendedClass,Metatable)
    
    --Extend the class.
    super:__classextended(ExtendedClass)
    
    --Return the extended class.
    return ExtendedClass
end



return NexusObject</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="56">
            <Properties>
              <string name="Name">PropertyValidator</string>
            </Properties>
            <Item class="ModuleScript" referent="57">
              <Properties>
                <string name="Name">NexusPropertyValidator</string>
                <string name="Source">--[[
TheNexusAvenger

Interface for a property validator.
--]]

local CLASS_NAME = "NexusPropertyValidator"



local NexusObjectFolder = script.Parent.Parent
local NexusInterface = require(NexusObjectFolder:WaitForChild("NexusInterface"))
local NexusPropertyValidator = NexusInterface:Extend()
NexusPropertyValidator:SetClassName(CLASS_NAME)



--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
NexusPropertyValidator:MustImplement("ValidateChange")



return NexusPropertyValidator</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="58">
              <Properties>
                <string name="Name">TypePropertyValidator</string>
                <string name="Source">--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local CLASS_NAME = "TypePropertyValidator"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusPropertyValidator = require(script.Parent:WaitForChild("NexusPropertyValidator"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName(CLASS_NAME)
TypePropertyValidator:Implements(NexusPropertyValidator)



--[[
Creates an event.
--]]
function TypePropertyValidator:__new(Type)
    self:InitializeSuper()
    self.Type = Type
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object,ValueName,Value)
    --Determine the type.
    local TypeMatches,ClassMatches = false,false
    local ValueType = typeof(Value)
    
    --Determine if the type matchs.
    if ValueType == self.Type then
        TypeMatches = true
    end
    
    --Determine if the class name matches.
    if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
        ValueType = Value.ClassName
        if Value:IsA(self.Type) then
            ClassMatches = true
        end
    end
    
    --Throw an error if the type is invalid.
    if not TypeMatches and not ClassMatches then
        error("Bad value for \""..tostring(ValueName).."\" ("..tostring(self.Type).." expected, got "..ValueType..")")
    end
    
    --Return the original value.
    return Value
end



return TypePropertyValidator</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="59">
          <Properties>
            <string name="Name">NexusProject</string>
            <string name="Source">--[[
TheNexusAvenger

Simplifies manages resources in large scale projects.
--]]

local CYCLIC_WARNING_TIME_REQUIREMENT = 5



local NexusObject = require(script:WaitForChild("NexusInstance"):WaitForChild("NexusObject"))
local NexusProjectContext = require(script:WaitForChild("NexusProjectContext"))

local NexusProject = NexusObject:Extend()
NexusProject:SetClassName("NexusProject")



--[[
Creates an instance of Nexus Project.
--]]
function NexusProject:__new(ReferenceInstance,SuppressCyclicWarnings)
	self:InitializeSuper()
	self.__BaseReference = ReferenceInstance
	self.__SuppressCyclicWarnings = SuppressCyclicWarnings == true
	
	self.__Links = {}
	self.__CachedResources = {}
	self.__LoadingResources = {}
	self.__InternalDependencies = {}
	self.__ExternalDependencies = {}
end

--[[
Adds an internal dependency reference.
--]]
function NexusProject:__AddInternalDependency(DependentPath,DependencyPath)
	--Add the table if it doesn't exist.
	if not self.__InternalDependencies[DependentPath] then
		self.__InternalDependencies[DependentPath] = {}
	end
	
	--Return if the reference exists.
	local Dependencies = self.__InternalDependencies[DependentPath]
	for _,Dependency in pairs(Dependencies) do
		if Dependency == DependencyPath then
			return
		end
	end
	
	--Add the dependency.
	table.insert(Dependencies,DependencyPath)
end

--[[
Adds an external dependency reference.
--]]
function NexusProject:__AddExternalDependency(DependentInstance,DependencyPath)
	--Add the table if it doesn't exist.
	if not self.__ExternalDependencies[DependentInstance] then
		self.__ExternalDependencies[DependentInstance] = {}
	end
	
	--Return if the reference exists.
	local Dependencies = self.__ExternalDependencies[DependentInstance]
	for _,Dependency in pairs(Dependencies) do
		if Dependency == DependencyPath then
			return
		end
	end
	
	--Add the dependency.
	table.insert(Dependencies,DependencyPath)
end

--[[
Adds a dependency reference.
--]]
function NexusProject:__AddDependency(DependentInstance,DependencyPath)
	if self:IsInstanceInPath(DependentInstance) then
		self:__AddInternalDependency(self:GetPathFromInstance(DependentInstance),DependencyPath)
	else
		self:__AddExternalDependency(DependentInstance,DependencyPath)
	end
end

--[[
Returns if a resource loading.
--]]
function NexusProject:IsLoading(Path)
	return self.__LoadingResources[Path] == true
end

--[[
Returns if an instance is part of the project.
--]]
function NexusProject:IsInstanceInPath(Ins)
	--Return true if it is or is under the base reference.
	if Ins == self.__BaseReference or self.__BaseReference:IsAncestorOf(Ins) then
		return true
	end
	
	--Return true if it is equal to or under a linked reference.
	for _,Reference in pairs(self.__Links) do
		if Ins == Reference or Reference:IsAncestorOf(Ins) then
			return true
		end
	end
	
	--Return false (not part of the project).
	return false
end

--[[
Returns if a dependent eventually has itself
as a dependent.
--]]
function NexusProject:IsResourceCyclic(Path)
	return self:GetDependencyPath(Path,Path) ~= nil
end

--[[
Returns the object reference for the given string.
--]]
function NexusProject:GetObjectReference(Path)
	--Split the path.
	local SplitPath = string.split(Path,".")
	if Path == "" then
		SplitPath = {}
	end
	
	--Get the base instance.
	local Base = self.__BaseReference
	for FirstItem,Reference in pairs(self.__Links) do
		if SplitPath[1] == FirstItem then
			table.remove(SplitPath,1)
			Base = Reference
			break
		end
	end
	
	--Get the reference.
	local Reference = Base
	for _,PathPart in pairs(SplitPath) do
		if Reference == nil then
			break
		end
		
		Reference = Reference:WaitForChild(PathPart)
	end
	
	--Retrun the reference.
	return Reference
end

--[[
Returns the project path for the given instance. Throws
an error if the instance isn't part of the project.
--]]
function NexusProject:GetPathFromInstance(Ins)
	local Path = ""
	local CurrentReference = Ins
	
	--Move up the path until nil is reached.
	while CurrentReference ~= nil do
		--Break the loop if the root of the project was reached.
		local ParentReached = false
		if CurrentReference == self.__BaseReference then
			break
		end
		for PathPart,Reference in pairs(self.__Links) do
			if Reference == CurrentReference then
				Path = PathPart.."."..Path
				ParentReached = true
				break
			end
		end
		if ParentReached then break end
		
		--Add to the path and move up.
		Path = CurrentReference.Name.."."..Path
		CurrentReference = CurrentReference.Parent
	end
	
	--If the current reference is nil, throw an error.
	if CurrentReference == nil then
		error("Instance isn't part of the project: "..tostring(Ins:GetFullName()))
	end
	
	--Return the path.
	return string.sub(Path,1,#Path - 1)
end

--[[
Returns a table of the path from a dependent to a sub-dependent.
Returns nil if the dependent doesn't have the dependency.
--]]
function NexusProject:GetDependencyPath(Dependent,Dependency,VisitiedDependents)
	VisitiedDependents = VisitiedDependents or {}
	VisitiedDependents[Dependent] = true
	local Dependencies = self.__InternalDependencies[Dependent]
	
	--Return nil if dependencies don't exists.
	if not Dependencies then
		return nil
	end
	
	--Return if the dependent has the given dependency.
	for _,OtherDependency in pairs(Dependencies) do
		if Dependency == OtherDependency then
			return {Dependent,Dependency}
		end
	end
	
	--Return if a dependency has the given dependency.
	for _,OtherDependency in pairs(Dependencies) do
		if not VisitiedDependents[OtherDependency] then
			local DependencyList =  self:GetDependencyPath(OtherDependency,Dependency,VisitiedDependents)
			if DependencyList then
				table.insert(DependencyList,1,Dependent)
				return DependencyList
			end
		end
	end
	
	--Return nil (not a dependency).
	return nil
end

--[[
Returns a context for getting resources. The first
parameter should be the "script" property. This is
used for detecting and warning cyclic dependencies
(A requires B, B requires A).
--]]
function NexusProject:GetContext(ScriptReference)
	return NexusProjectContext.new(ScriptReference,self)
end

--[[
Returns the resource for the given path. If it is a
ModuleScript, it is required and returned.
--]]
function NexusProject:GetResource(Path)
	--Return a cached resource if it exists.
	local CachedResource = self.__CachedResources[Path]
	if CachedResource then
		return CachedResource
	end
	
	--Get the resource and require it if it is a ModuleScript.
	self.__LoadingResources[Path] = true
	coroutine.wrap(function()
		local Resource = self:GetObjectReference(Path)
		if typeof(Resource) == "Instance" and Resource.IsA and Resource:IsA("ModuleScript") then
			Resource = require(Resource)
		end
		
		--Cache the resource.
		if not self.__CachedResources[Path] then
			self.__CachedResources[Path] = Resource
		end
		
		--Register the resource as loaded.
		self.__LoadingResources[Path] = nil
	end)()
	
	--Start a loop and wait for the instance.
	local StartTime = tick()
	local WarningDisplayed = false
	local Resource
	while Resource == nil and self.__LoadingResources[Path] do
		Resource = self.__CachedResources[Path]
		
		--Break if the resource exists.
		if Resource ~= nil then
			return Resource
		end
	
		--Display a warning if it is cyclic.
		if WarningDisplayed == false and self.__SuppressCyclicWarnings ~= true and tick() - StartTime > CYCLIC_WARNING_TIME_REQUIREMENT then
			local DependencyPath = self:GetDependencyPath(Path,Path)
			if DependencyPath then
				WarningDisplayed = true
				warn("A dependency loop exists:")
				for _,Path in pairs(DependencyPath) do
					warn("\t"..Path)
				end 
				warn("Use NexusProject::SetResource or NexusProjectContext::SetContextResource to allow the loop to end without having to load the resources.")
			end
		end
		wait()
	end
	
	--Return the resource.
	return self.__CachedResources[Path]
end

--[[
Creates a link between a string and a game
reference. Note that it will only be valid for the
first word (ex: "game" in "game.Workspace") and
the given string should NOT have a period. Also
note that links are case sensitive.
--]]
function NexusProject:CreatePathLink(Reference,Object)
	self.__Links[Reference] = Object
end

--[[
Registers a resource with a given path. If GetResource
is called, it will use what is registered.
--]]
function NexusProject:SetResource(Path,Resource)
	self.__CachedResources[Path] = Resource
end



return NexusProject</string>
          </Properties>
          <Item class="ModuleScript" referent="60">
            <Properties>
              <string name="Name">NexusProjectContext</string>
              <string name="Source">--[[
TheNexusAvenger

Allows tracking of dependencies in a project.
--]]

local NexusObject = require(script.Parent:WaitForChild("NexusInstance"):WaitForChild("NexusObject"))

local NexusProjectContext = NexusObject:Extend()
NexusProjectContext:SetClassName("NexusProjectContext")



--[[
Creates a Nexus Project Context object.
--]]
function NexusProjectContext:__new(RequiringScript,Project)
	self:InitializeSuper()
	self.__RequiringScript = RequiringScript
	self.__Project = Project
end

--[[
Returns if a resource loading.
--]]
function NexusProjectContext:IsLoading(Path)
	return self.__Project:IsLoading(Path)
end

--[[
Returns if an instance is part of the project.
--]]
function NexusProjectContext:IsInstanceInPath(Ins)
	return self.__Project:IsInstanceInPath(Ins)
end

--[[
Returns if a dependent eventually has itself
as a dependent.
--]]
function NexusProjectContext:IsResourceCyclic(Path)
	return self.__Project:IsResourceCyclic(Path)
end

--[[
Returns the object reference for the given string.
--]]
function NexusProjectContext:GetObjectReference(Path)
	return self.__Project:GetObjectReference(Path)
end

--[[
Returns the project path for the given instance. Throws
an error if the instance isn't part of the project.
--]]
function NexusProjectContext:GetPathFromInstance(Ins)
	return self.__Project:GetPathFromInstance(Ins)
end

--[[
Returns a table of the path from a dependent to a sub-dependent.
Returns nil if the dependent doesn't have the dependency.
--]]
function NexusProjectContext:GetDependencyPath(Dependent,Dependency,VisitiedDependents)
	return self.__Project:GetDependencyPath(Dependent,Dependency,VisitiedDependents)
end

--[[
Returns a context for getting resources. The first
parameter should be the "script" property. This is
used for detecting and warning cyclic dependencies
(A requires B, B requires A).
--]]
function NexusProjectContext:GetContext(ScriptReference)
	return self.__Project:GetContext(ScriptReference)
end

--[[
Returns the resource for the given path. If it is a
ModuleScript, it is required and returned.
--]]
function NexusProjectContext:GetResource(Path)
	self.__Project:__AddDependency(self.__RequiringScript,Path)
	return self.__Project:GetResource(Path)
end

--[[
Creates a link between a string and a game
reference. Note that it will only be valid for the
first word (ex: "game" in "game.Workspace") and
the given string should NOT have a period. Also
note that links are case sensitive.
--]]
function NexusProjectContext:CreatePathLink(Reference,Object)
	self.__Project:CreatePathLink(Reference,Object)
end

--[[
Registers a resource with a given path. If GetResource
is called, it will use what is registered.
--]]
function NexusProjectContext:SetResource(Path,Resource)
	self.__Project:SetResource(Path,Resource)
end

--[[
Sets the resource for the given context.
--]]
function NexusProjectContext:SetContextResource(Resource)
	local Path = self:GetPathFromInstance(self.__RequiringScript)
	self.__Project:SetResource(Path,Resource)
end



return NexusProjectContext</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="61">
            <Properties>
              <string name="Name">NexusInstance</string>
            </Properties>
            <Item class="Folder" referent="62">
              <Properties>
                <string name="Name">Event</string>
              </Properties>
              <Item class="ModuleScript" referent="63">
                <Properties>
                  <string name="Name">LuaEvent</string>
                  <string name="Source">--[[
TheNexusAvenger

Implements the NexusEvent interface using
Lua coroutines.
--]]

local CLASS_NAME = "LuaEvent"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("NexusEvent"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local LuaEvent = NexusObject:Extend()
LuaEvent:SetClassName(CLASS_NAME)
LuaEvent:Implements(NexusEvent)



--[[
Creates an event.
--]]
function LuaEvent:__new()
    self:InitializeSuper()
    self.Connections = {}
end

--[[
Invoked when a connection is disconnected.
--]]
function LuaEvent:Disconnected(Connection)
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function LuaEvent:Disconnect()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection,_ in pairs(self.Connections) do
        table.insert(ConnectionsToDisconnect,Connection)
    end
    
    --Disconnect the events.
    for _,Connection in pairs(ConnectionsToDisconnect) do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function LuaEvent:Connect(Function)
    --Create and store the connection.
    local Connection = NexusConnection.new(self,Function)
    self.Connections[Connection] = true
    
    --Return the connection.
    return Connection
end


--[[
Fires the event.
--]]
function LuaEvent:Fire(...)
    local Parameters = {...}
    for Connection,_ in pairs(self.Connections) do
         coroutine.wrap(function()
            Connection:Fire(unpack(Parameters))
         end)()
    end
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function LuaEvent:Wait()
    local Return
    
    --Create the connection.
    local Connection = self:Connect(function(...)
        Return = {...}
    end)
    
    --Wait for the connection to be fired.
    while not Return do wait() end
    
    --Disconnect the connection and return the fired parameters.
    Connection:Disconnect()
    return unpack(Return)
end



return LuaEvent</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">NexusConnection</string>
                  <string name="Source">--[[
TheNexusAvenger

Represents an event connection.
--]]

local CLASS_NAME = "NexusConnection"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName(CLASS_NAME)



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new(Event,ConnectionFunction)
    self:InitializeSuper()
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire(...)
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">NexusEvent</string>
                  <string name="Source">--[[
TheNexusAvenger

Interface for an event.
--]]

local CLASS_NAME = "NexusEvent"



local NexusObjectFolder = script.Parent.Parent
local NexusInterface = require(NexusObjectFolder:WaitForChild("NexusInterface"))
local NexusEvent = NexusInterface:Extend()
NexusEvent:SetClassName(CLASS_NAME)



--[[
Invoked when a connection is disconnected.
--]]
NexusEvent:MustImplement("Disconnected")

--[[
Establishes a function to be called whenever
the event is raised.
--]]
NexusEvent:MustImplement("Connect")

--[[
Disconnects all connected events.
--]]
NexusEvent:MustImplement("Disconnect")

--[[
Fires the event.
--]]
NexusEvent:MustImplement("Fire")

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
NexusEvent:MustImplement("Wait")



return NexusEvent</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="66">
                <Properties>
                  <string name="Name">NexusEventCreator</string>
                  <string name="Source">--[[
TheNexusAvenger

Creates events depending on the preferred event
type and if the platform is Roblox. Extra work
is required to actually make Nexus Instance
work in a non-Roblox environment.
--]]

local USE_NON_ROBLOX_EVENTS = false

local CLASS_NAME = "NexusEventCreator"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local LuaEvent = require(script.Parent:WaitForChild("LuaEvent"))
local RobloxEvent = require(script.Parent:WaitForChild("RobloxEvent"))

local NexusEventCreator = NexusObject:Extend()
NexusEventCreator:SetClassName(CLASS_NAME)



--[[
Returns if Roblox events should be used.
--]]
function NexusEventCreator:UseRobloxEvents()
    if USE_NON_ROBLOX_EVENTS then
        return false
    else
        return Instance ~= nil
    end
end

--[[
Creates an event.
--]]
function NexusEventCreator:CreateEvent()
    if NexusEventCreator:UseRobloxEvents() then
        return RobloxEvent.new()
    else
        return LuaEvent.new()
    end
end



return NexusEventCreator</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="67">
                <Properties>
                  <string name="Name">RobloxEvent</string>
                  <string name="Source">--[[
TheNexusAvenger

Implements the NexusEvent interface using
Roblox's BindableEvents.
--]]

local CLASS_NAME = "RobloxEvent"



local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("NexusEvent"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local RobloxEvent = NexusObject:Extend()
RobloxEvent:SetClassName(CLASS_NAME)
RobloxEvent:Implements(NexusEvent)



--[[
Creates an event.
--]]
function RobloxEvent:__new()
    self:InitializeSuper()
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments,{__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function RobloxEvent:Disconnected(Connection)
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function RobloxEvent:Disconnect()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection,_ in pairs(self.Connections) do
        table.insert(ConnectionsToDisconnect,Connection)
    end
    
    --Disconnect the events.
    for _,Connection in pairs(ConnectionsToDisconnect) do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function RobloxEvent:Connect(Function)
    --Create the connection.
    local Connection = NexusConnection.new(self,Function)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[Arguments] = nil

        --Fire the event.
        Connection:Fire(unpack(Arguments.Arguments,1,Arguments.Total))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end


--[[
Fires the event.
--]]
function RobloxEvent:Fire(...)
    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = {
        Arguments = {...},
        Total = select("#",...),
    }
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function RobloxEvent:Wait()
    --Wait for the event.
    local UUID = self.BindableEvent.Event:Wait()

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[Arguments] = nil
    return unpack(Arguments.Arguments,1,Arguments.Total)
end



return RobloxEvent</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="68">
              <Properties>
                <string name="Name">NexusInstance</string>
                <string name="Source">--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]

local CLASS_NAME = "NexusInstance"



local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEventCreator = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEventCreator"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName(CLASS_NAME)



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new()
    --Set up the base object.
    self:InitializeSuper()
    
    --Set up the internal properties.
    self:__InitInternalProperties()
    
    --Set up the metamethods.
    self:__InitMetaMethods()
end

--[[
Creates an __index metamethod for an object. Used to
setup custom indexing.
--]]
function NexusInstance:__createindexmethod(Object,Class,RootClass)
    --Get the base method.
    local BaseIndexMethod = self.super:__createindexmethod(Object,Class,RootClass)
    
    --Return a wrapped method.
    return function(MethodObject,Index)
        --Return an internal property.
        local InternalProperties = rawget(Object.object,"__InternalProperties")
        if InternalProperties then
            local Value = InternalProperties[Index]
            if Value ~= nil then
                return Value
            end
        end
        
        --Return the base return.
        return BaseIndexMethod(MethodObject,Index)
    end
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEventCreator:CreateEvent()
    self.Changed = self.__ChangedEvent
    
    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent
    
    --Set up custom indexing.
    local Metatable = getmetatable(self.object)
    local ExistingIndex = Metatable.__index
    
    local function index(_,Index)
        --Return the internal property.
        local InternalPropertyValue = rawget(InternalProperties,Index)
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end
        
        --Return the base return.
        return ExistingIndex(self,Index)
    end
    Metatable.__index = index
    
    --Set up changes.
    Metatable.__newindex = function(_,Index,Value)
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end
        
        --Return if the new and old values are the same.
        if index(self,Index) == Value then
            return
        end
        
        --Validate the value.
        for _,Validator in pairs(GenericPropertyValidators) do
            Value = Validator:ValidateChange(self,Index,Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _,Validator in pairs(Validators) do
                Value = Validator:ValidateChange(self,Index,Value)
            end
        end
        
        --Change the property.
        rawset(InternalProperties,Index,Value)
        
        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _,Finalizer in pairs(GenericPropertyFinalizers) do
            Finalizer(Index,Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _,Finalizer in pairs(Finalizers) do
                Finalizer(Index,Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end
        
        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end
        
        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator)
    table.insert(self.__GenericPropertyValidators,Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName,Validator)
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName],Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer)
    table.insert(self.__GenericPropertyFinalizers,Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName,Finalizer)
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName],Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName)
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName)
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName)
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName)
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEventCreator:CreateEvent()
    end
    
    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in pairs(self.__PropertyChanged) do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="69">
              <Properties>
                <string name="Name">NexusInterface</string>
                <string name="Source">--[[
TheNexusAvenger

Provides a function "interface" for dependant classes
to implement.
--]]

--Class name of the object.
local CLASS_NAME = "NexusInterface"



local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusInterface = NexusObject:Extend()
NexusInterface:SetClassName(CLASS_NAME)
NexusInterface.RequiredAttributes = {}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusInterface:__classextended(OtherClass)
    OtherClass.RequiredAttributes = {}
end
    
--[[
Sets an attribute as required for an object.
Although it is intended to be a name of a function,
it can be any type, and can be implemented
after the constructor is run.
--]]
function NexusInterface:MustImplement(Attribute)
    table.insert(self.RequiredAttributes,Attribute)
end

--[[
Returns a list of the missing attributes from
an object based on the interface. If no attributes
are missing, an empty list is returned.
--]]
function NexusInterface:GetMissingAttributes(Object)
    --Get the missing attributes.
    local MissingAttributes = {}
    for _,Attribute in pairs(self.RequiredAttributes) do
        if not Object[Attribute] then
            table.insert(MissingAttributes,Attribute)
        end
    end
    
    --Return the missing attributes.
    return MissingAttributes
end



return NexusInterface</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="70">
              <Properties>
                <string name="Name">NexusObject</string>
                <string name="Source">--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]

--Class name of the object.
local CLASS_NAME = "NexusObject"

--Metamethods to pass through.
local METATABLE_PASSTHROUGH = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



local NexusObject = {
    ClassName = CLASS_NAME,
    Interfaces = {},
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table)
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil
    
    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    
    return String
end

--[[
Returns the first object from the interfaces.
--]]
local function GetFromInterfaces(Object,Class,Index)
    for _,Interface in pairs(Class:GetInterfaces(Class)) do
        local InterfaceReturn = Interface[Index]
        if InterfaceReturn then
            return InterfaceReturn
        end
    end
end



--[[
Creates an instance of a NexusObject. This is used
as a base.
--]]
function NexusObject.new(...)
    --Create the object.
    local self = {}
    self.class = NexusObject
    self.object = self
    
    --Set up the metatable.
    local Metatable = {}
    Metatable.__index = function(_,Index)
        local RawGet = rawget(self,Index)
        if RawGet then
            return RawGet
        end
        
        return NexusObject[Index]
    end
    setmetatable(self,Metatable)
    
    --Add the metamethod passthrough.
    for _,Name in pairs(METATABLE_PASSTHROUGH) do
        Metatable[Name] = function(_,...)
            return self[Name](self,...)
        end
    end
    
    --Run the constructor.
    self:__new(...)
    
    --Return the object.
    return self
end

--[[
Constructor run for the class.
--]]
function NexusObject:__new()
    
end

--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass)
    OtherClass.Interfaces = {}
end

--[[
Creates an __index metamethod for an object. Used to
setup custom indexing.
--]]
function NexusObject:__createindexmethod(Object,Class,RootClass)
    --Set the root class.
    if not RootClass then
        RootClass = Class
    end
    
    --Get the method.
    if Class.super then
        --[[
        Returns the value for an index of an object.
        --]]
        return function(_,Index)
            if Index == "super" then
                --Create a temporary object.
                local TempObject = {}
                TempObject.object = Object
                
                --Set the metatable to redirect the next "super".
                local Metatable = {}
                Metatable.__index = RootClass:__createindexmethod(Object,Class.super,RootClass)
                Metatable.__newindex = function(_,Index,Value)
                    Object[Index] = Value
                end
                setmetatable(TempObject,Metatable)
                
                --Return the temporary object.
                return TempObject
            else
                --Get the normal property from the object or class.
                local RawReturn = rawget(Object,Index)
                if RawReturn ~= nil then
                    return RawReturn
                end
                
                return Class[Index]
            end
        end
    else
        --[[
        Returns the value for an index of an object.
        --]]
        return function(_,Index)
            local RawReturn = rawget(Object,Index)
            if RawReturn ~= nil then
                return RawReturn
            end
            
            return Class[Index]
        end
    end
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring()
    local MemoryAddress = string.sub(RawToString(self),8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject)
    return rawequal(self,OtherObject)
end

--[[
Initializes the super class. The paramters given
by "..." are passed into the constructor of the
super class (__new(...)). It should be called
in the constructor of the class.
--]]
function NexusObject:InitializeSuper(...)
    if self.super then
        self.super:__new(...)
    end
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName)
    self.ClassName = ClassName
end

--[[
Sets the class as implementing a given interface. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:Implements(Interface)
    --Throw an error if the interface isn't an interface.
    if not Interface:IsA("NexusInterface") then
        error(tostring(Interface).." is not an interface.")
    end
    
    --Add the interface.
    table.insert(self.Interfaces,Interface)
end

--[[
Returns a list of the interfaces that the
class implements. This includes ones implemented
by super classes.
--]]
function NexusObject:GetInterfaces()
    --Get the super class's interfaces.
    local Interfaces = {}
    if self.super then
        Interfaces = self.super:GetInterfaces()
    end
    
    --Add the classes interfaces.
    local ClassInterfaces = self.Interfaces
    if ClassInterfaces then
        for _,Interface in pairs(ClassInterfaces) do
             table.insert(Interfaces,Interface)
        end
    end
    
    --Return the interfaces.
    return Interfaces
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName)
    --If the class name matches the class name, return true.
    if self.ClassName == ClassName then
        return true
    end
    
    --If an interface matches the name, return true.
    if self.Interfaces then
        for _,Interface in pairs(self.Interfaces) do
            if Interface:IsA(ClassName) then
                return true
            end
        end
    end
    
    --If a super class exists, return the result of the super.
    if self.super then
        return self.super:IsA(ClassName)
    end
    
    --Return false (no match).
    return false
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend()
    local super = self
    local ExtendedClass = {
        super = super,
    }
    
    --[[
    Creates an instance of the class.
    --]]
    function ExtendedClass.new(...)
        --Create the object.
        local self = {}
        self.class = ExtendedClass
        self.object = self
        
        --Set up the metatable.
        local Metatable = {}
        Metatable.__index = ExtendedClass:__createindexmethod(self,ExtendedClass)
        setmetatable(self,Metatable)
        
        --Add the metamethod passthrough.
        for _,Name in pairs(METATABLE_PASSTHROUGH) do
            Metatable[Name] = function(_,...)
                return self[Name](self,...)
            end
        end
        
        --Run the constructor.
        self:__new(...)
        
        --Determine the missing attributes.
        local MissingAttributes = {}
        for _,Interface in pairs(self:GetInterfaces()) do
            for _,Attribute in pairs(Interface:GetMissingAttributes(self)) do
                table.insert(MissingAttributes,{Interface.ClassName,Attribute})
            end
        end
        
        --Throw an error if missing attributes exist.
        if #MissingAttributes > 0 then
            --Create the message.
            local ErrorMessage = tostring(self.ClassName).." does not implement the following:"
            for _,Attribute in pairs(MissingAttributes) do
                ErrorMessage = ErrorMessage.."\n\t"..tostring(Attribute[1]).."."..tostring(Attribute[2])
            end
            
            --Throw the error.
            error(ErrorMessage)
        end
        
        --Return the object.
        return self
    end
    
    --[[
    Constructor run for the class.
    --]]
    function ExtendedClass:__new(...)
        self:InitializeSuper(...)
    end
    
    --[[
    Called after extending when another class extends
    the class. The purpose of this is to add attributes
    to the class.
    --]]
    function ExtendedClass:__classextended(OtherClass)
        self.super:__classextended(OtherClass)
    end
    
    --Set up the metatable for indexing.
    local Metatable = {}
    Metatable.__index = function(_,Index)
        --Return the value for the class.
        local ClassReturn = rawget(ExtendedClass,Index)
        if ClassReturn ~= nil then
            return ClassReturn
        end
        
        --Return the value for the super classes.
        local SuperClassReturn = super[Index]
        if SuperClassReturn ~= nil then
            return SuperClassReturn
        end
        
        --Return the value for the interfaces.
        return GetFromInterfaces(ExtendedClass,ExtendedClass,Index)
    end
    setmetatable(ExtendedClass,Metatable)
    
    --Extend the class.
    super:__classextended(ExtendedClass)
    
    --Return the extended class.
    return ExtendedClass
end



return NexusObject</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="71">
              <Properties>
                <string name="Name">PropertyValidator</string>
              </Properties>
              <Item class="ModuleScript" referent="72">
                <Properties>
                  <string name="Name">NexusPropertyValidator</string>
                  <string name="Source">--[[
TheNexusAvenger

Interface for a property validator.
--]]

local CLASS_NAME = "NexusPropertyValidator"



local NexusObjectFolder = script.Parent.Parent
local NexusInterface = require(NexusObjectFolder:WaitForChild("NexusInterface"))
local NexusPropertyValidator = NexusInterface:Extend()
NexusPropertyValidator:SetClassName(CLASS_NAME)



--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
NexusPropertyValidator:MustImplement("ValidateChange")



return NexusPropertyValidator</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="73">
                <Properties>
                  <string name="Name">TypePropertyValidator</string>
                  <string name="Source">--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local CLASS_NAME = "TypePropertyValidator"



local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusPropertyValidator = require(script.Parent:WaitForChild("NexusPropertyValidator"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName(CLASS_NAME)
TypePropertyValidator:Implements(NexusPropertyValidator)



--[[
Creates an event.
--]]
function TypePropertyValidator:__new(Type)
    self:InitializeSuper()
    self.Type = Type
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object,ValueName,Value)
    --Determine the type.
    local TypeMatches,ClassMatches = false,false
    local ValueType = typeof(Value)
    
    --Determine if the type matchs.
    if ValueType == self.Type then
        TypeMatches = true
    end
    
    --Determine if the class name matches.
    if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
        ValueType = Value.ClassName
        if Value:IsA(self.Type) then
            ClassMatches = true
        end
    end
    
    --Throw an error if the type is invalid.
    if not TypeMatches and not ClassMatches then
        error("Bad value for \""..tostring(ValueName).."\" ("..tostring(self.Type).." expected, got "..ValueType..")")
    end
    
    --Return the original value.
    return Value
end



return TypePropertyValidator</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>